/* automatically generated by rust-bindgen 0.69.4 */

#[doc = " \\brief Used to specify the logging layer mode using a bitwise combination\nof rocblas_layer_mode values."]
pub type rocblas_layer_mode_flags = u32;
impl rocblas_direct_ {
    #[doc = "< Householder matrices applied from the right."]
    pub const rocblas_forward_direction: rocblas_direct_ = rocblas_direct_(171);
}
impl rocblas_direct_ {
    #[doc = "< Householder matrices applied from the left."]
    pub const rocblas_backward_direction: rocblas_direct_ = rocblas_direct_(172);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify the order in which multiple Householder matrices are\napplied together"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_direct_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify the order in which multiple Householder matrices are\napplied together"]
pub use self::rocblas_direct_ as rocblas_direct;
impl rocblas_storev_ {
    #[doc = "< Householder vectors are stored in the columns of a matrix."]
    pub const rocblas_column_wise: rocblas_storev_ = rocblas_storev_(181);
}
impl rocblas_storev_ {
    #[doc = "< Householder vectors are stored in the rows of a matrix."]
    pub const rocblas_row_wise: rocblas_storev_ = rocblas_storev_(182);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify how householder vectors are stored in a matrix of\nvectors"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_storev_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify how householder vectors are stored in a matrix of\nvectors"]
pub use self::rocblas_storev_ as rocblas_storev;
impl rocblas_svect_ {
    #[doc = "< The entire associated orthogonal/unitary matrix is computed."]
    pub const rocblas_svect_all: rocblas_svect_ = rocblas_svect_(191);
}
impl rocblas_svect_ {
    #[doc = "< Only the singular vectors are computed and\nstored in output array."]
    pub const rocblas_svect_singular: rocblas_svect_ = rocblas_svect_(192);
}
impl rocblas_svect_ {
    #[doc = "< Only the singular vectors are computed and\noverwrite the input matrix."]
    pub const rocblas_svect_overwrite: rocblas_svect_ = rocblas_svect_(193);
}
impl rocblas_svect_ {
    #[doc = "< No singular vectors are computed."]
    pub const rocblas_svect_none: rocblas_svect_ = rocblas_svect_(194);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify how the singular vectors are to be computed and\nstored"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_svect_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify how the singular vectors are to be computed and\nstored"]
pub use self::rocblas_svect_ as rocblas_svect;
impl rocblas_workmode_ {
    #[doc = "< Out-of-place computations are allowed; this\nrequires extra device memory for workspace."]
    pub const rocblas_outofplace: rocblas_workmode_ = rocblas_workmode_(201);
}
impl rocblas_workmode_ {
    #[doc = "< If not enough memory is available, this forces in-place computations."]
    pub const rocblas_inplace: rocblas_workmode_ = rocblas_workmode_(202);
}
#[repr(transparent)]
#[doc = " \\brief Used to enable the use of fast algorithms (with out-of-place\ncomputations) in some of the routines"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_workmode_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to enable the use of fast algorithms (with out-of-place\ncomputations) in some of the routines"]
pub use self::rocblas_workmode_ as rocblas_workmode;
impl rocblas_evect_ {
    #[doc = "< Compute eigenvectors for the original symmetric/Hermitian\nmatrix."]
    pub const rocblas_evect_original: rocblas_evect_ = rocblas_evect_(211);
}
impl rocblas_evect_ {
    #[doc = "< Compute eigenvectors for the symmetric tridiagonal\nmatrix."]
    pub const rocblas_evect_tridiagonal: rocblas_evect_ = rocblas_evect_(212);
}
impl rocblas_evect_ {
    #[doc = "< No eigenvectors are computed."]
    pub const rocblas_evect_none: rocblas_evect_ = rocblas_evect_(213);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify how the eigenvectors are to be computed"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_evect_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify how the eigenvectors are to be computed"]
pub use self::rocblas_evect_ as rocblas_evect;
impl rocblas_eform_ {
    #[doc = "< The problem is \\f$Ax = \\lambda Bx\\f$."]
    pub const rocblas_eform_ax: rocblas_eform_ = rocblas_eform_(221);
}
impl rocblas_eform_ {
    #[doc = "< The problem is \\f$ABx = \\lambda x\\f$."]
    pub const rocblas_eform_abx: rocblas_eform_ = rocblas_eform_(222);
}
impl rocblas_eform_ {
    #[doc = "< The problem is \\f$BAx = \\lambda x\\f$."]
    pub const rocblas_eform_bax: rocblas_eform_ = rocblas_eform_(223);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify the form of the generalized eigenproblem"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_eform_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify the form of the generalized eigenproblem"]
pub use self::rocblas_eform_ as rocblas_eform;
impl rocblas_erange_ {
    #[doc = "< All eigenvalues will be found."]
    pub const rocblas_erange_all: rocblas_erange_ = rocblas_erange_(231);
}
impl rocblas_erange_ {
    #[doc = "< All eigenvalues in the half-open interval\n\\f$(vl, vu]\\f$ will be found."]
    pub const rocblas_erange_value: rocblas_erange_ = rocblas_erange_(232);
}
impl rocblas_erange_ {
    #[doc = "< The \\f$il\\f$-th through \\f$iu\\f$-th eigenvalues will be found."]
    pub const rocblas_erange_index: rocblas_erange_ = rocblas_erange_(233);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify the type of range in which eigenvalues will be found\nin partial eigenvalue decompositions"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_erange_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify the type of range in which eigenvalues will be found\nin partial eigenvalue decompositions"]
pub use self::rocblas_erange_ as rocblas_erange;
impl rocblas_eorder_ {
    #[doc = "< The computed eigenvalues will be grouped by split-off\nblocks and arranged in increasing order within each block."]
    pub const rocblas_eorder_blocks: rocblas_eorder_ = rocblas_eorder_(241);
}
impl rocblas_eorder_ {
    #[doc = "< All computed eigenvalues of the entire matrix will be\nordered from smallest to largest."]
    pub const rocblas_eorder_entire: rocblas_eorder_ = rocblas_eorder_(242);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify whether the eigenvalues are grouped and ordered by blocks"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_eorder_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify whether the eigenvalues are grouped and ordered by blocks"]
pub use self::rocblas_eorder_ as rocblas_eorder;
impl rocblas_esort_ {
    #[doc = "< The computed eigenvalues will not be sorted."]
    pub const rocblas_esort_none: rocblas_esort_ = rocblas_esort_(251);
}
impl rocblas_esort_ {
    #[doc = "< The computed eigenvalues will be sorted in ascending order."]
    pub const rocblas_esort_ascending: rocblas_esort_ = rocblas_esort_(252);
}
#[repr(transparent)]
#[doc = " \\brief Used in the Jacobi methods to specify whether the eigenvalues are sorted\nin increasing order"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_esort_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used in the Jacobi methods to specify whether the eigenvalues are sorted\nin increasing order"]
pub use self::rocblas_esort_ as rocblas_esort;
impl rocblas_srange_ {
    #[doc = "< All singular values will be found."]
    pub const rocblas_srange_all: rocblas_srange_ = rocblas_srange_(261);
}
impl rocblas_srange_ {
    #[doc = "< All singular values in the half-open interval\n\\f$(vl, vu]\\f$ will be found."]
    pub const rocblas_srange_value: rocblas_srange_ = rocblas_srange_(262);
}
impl rocblas_srange_ {
    #[doc = "< The \\f$il\\f$-th through \\f$iu\\f$-th singular values will be found."]
    pub const rocblas_srange_index: rocblas_srange_ = rocblas_srange_(263);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify the type of range in which singular values will be found\nin partial singular value decompositions"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_srange_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify the type of range in which singular values will be found\nin partial singular value decompositions"]
pub use self::rocblas_srange_ as rocblas_srange;
#[doc = " \\brief Forward-declaration of opaque struct containing data used for the re-factorization interfaces."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocsolver_rfinfo_ {
    _unused: [u8; 0],
}
#[doc = " \\brief A handle to a structure containing matrix descriptors and metadata required to interact\nwith rocSPARSE when using the rocSOLVER re-factorization functionality. It needs to be initialized\nwith \\ref rocsolver_create_rfinfo and destroyed with \\ref rocsolver_destroy_rfinfo."]
pub type rocsolver_rfinfo = *mut rocsolver_rfinfo_;
impl rocsolver_rfinfo_mode_ {
    pub const rocsolver_rfinfo_mode_lu: rocsolver_rfinfo_mode_ = rocsolver_rfinfo_mode_(271);
}
impl rocsolver_rfinfo_mode_ {
    pub const rocsolver_rfinfo_mode_cholesky: rocsolver_rfinfo_mode_ = rocsolver_rfinfo_mode_(272);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify the mode of the rfinfo struct required by the re-factorization functionality."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsolver_rfinfo_mode_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify the mode of the rfinfo struct required by the re-factorization functionality."]
pub use self::rocsolver_rfinfo_mode_ as rocsolver_rfinfo_mode;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocblas_handle {
    _unused: [u8; 0],
}
#[doc = " \\brief rocblas_handle is a structure holding the rocblas library context.\n It must be initialized using rocblas_create_handle(),\n and the returned handle must be passed\n to all subsequent library function calls.\n It should be destroyed at the end using rocblas_destroy_handle()."]
pub type rocblas_handle = *mut _rocblas_handle;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
#[doc = " \\brief Forward declaration of hipStream_t"]
pub type hipStream_t = *mut ihipStream_t;
pub type rocblas_int = i32;
#[doc = " \\brief Stride between matrices or vectors in strided_batched functions"]
pub type rocblas_stride = i64;
#[doc = " \\brief Struct to represent a complex number with single precision real and imaginary parts."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocblas_float_complex {
    pub x: f32,
    pub y: f32,
}
#[doc = " \\brief Struct to represent a complex number with double precision real and imaginary parts."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocblas_double_complex {
    pub x: f64,
    pub y: f64,
}
impl rocblas_operation_ {
    #[doc = "< Operate with the matrix."]
    pub const rocblas_operation_none: rocblas_operation_ = rocblas_operation_(111);
}
impl rocblas_operation_ {
    #[doc = "< Operate with the transpose of the matrix."]
    pub const rocblas_operation_transpose: rocblas_operation_ = rocblas_operation_(112);
}
impl rocblas_operation_ {
    pub const rocblas_operation_conjugate_transpose: rocblas_operation_ = rocblas_operation_(113);
}
#[repr(transparent)]
#[doc = " \\brief Used to specify whether the matrix is to be transposed or not."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_operation_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used to specify whether the matrix is to be transposed or not."]
pub use self::rocblas_operation_ as rocblas_operation;
impl rocblas_fill_ {
    #[doc = "< Upper triangle."]
    pub const rocblas_fill_upper: rocblas_fill_ = rocblas_fill_(121);
}
impl rocblas_fill_ {
    #[doc = "< Lower triangle."]
    pub const rocblas_fill_lower: rocblas_fill_ = rocblas_fill_(122);
}
impl rocblas_fill_ {
    pub const rocblas_fill_full: rocblas_fill_ = rocblas_fill_(123);
}
#[repr(transparent)]
#[doc = " \\brief Used by the Hermitian, symmetric and triangular matrix\n routines to specify whether the upper, or lower triangle is being referenced."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_fill_(pub ::std::os::raw::c_int);
#[doc = " \\brief Used by the Hermitian, symmetric and triangular matrix\n routines to specify whether the upper, or lower triangle is being referenced."]
pub use self::rocblas_fill_ as rocblas_fill;
impl rocblas_diagonal_ {
    #[doc = "< Non-unit triangular."]
    pub const rocblas_diagonal_non_unit: rocblas_diagonal_ = rocblas_diagonal_(131);
}
impl rocblas_diagonal_ {
    #[doc = "< Unit triangular."]
    pub const rocblas_diagonal_unit: rocblas_diagonal_ = rocblas_diagonal_(132);
}
#[repr(transparent)]
#[doc = " \\brief It is used by the triangular matrix routines to specify whether the\n matrix is unit triangular."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_diagonal_(pub ::std::os::raw::c_int);
#[doc = " \\brief It is used by the triangular matrix routines to specify whether the\n matrix is unit triangular."]
pub use self::rocblas_diagonal_ as rocblas_diagonal;
impl rocblas_side_ {
    #[doc = "< Multiply general matrix by symmetric,\nHermitian, or triangular matrix on the left."]
    pub const rocblas_side_left: rocblas_side_ = rocblas_side_(141);
}
impl rocblas_side_ {
    #[doc = "< Multiply general matrix by symmetric,\nHermitian, or triangular matrix on the right."]
    pub const rocblas_side_right: rocblas_side_ = rocblas_side_(142);
}
impl rocblas_side_ {
    pub const rocblas_side_both: rocblas_side_ = rocblas_side_(143);
}
#[repr(transparent)]
#[doc = " \\brief Indicates the side matrix A is located relative to matrix B during multiplication."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_side_(pub ::std::os::raw::c_int);
#[doc = " \\brief Indicates the side matrix A is located relative to matrix B during multiplication."]
pub use self::rocblas_side_ as rocblas_side;
impl rocblas_status_ {
    #[doc = "< Success"]
    pub const rocblas_status_success: rocblas_status_ = rocblas_status_(0);
}
impl rocblas_status_ {
    #[doc = "< Handle not initialized, invalid or null"]
    pub const rocblas_status_invalid_handle: rocblas_status_ = rocblas_status_(1);
}
impl rocblas_status_ {
    #[doc = "< Function is not implemented"]
    pub const rocblas_status_not_implemented: rocblas_status_ = rocblas_status_(2);
}
impl rocblas_status_ {
    #[doc = "< Invalid pointer argument"]
    pub const rocblas_status_invalid_pointer: rocblas_status_ = rocblas_status_(3);
}
impl rocblas_status_ {
    #[doc = "< Invalid size argument"]
    pub const rocblas_status_invalid_size: rocblas_status_ = rocblas_status_(4);
}
impl rocblas_status_ {
    #[doc = "< Failed internal memory allocation, copy or dealloc"]
    pub const rocblas_status_memory_error: rocblas_status_ = rocblas_status_(5);
}
impl rocblas_status_ {
    #[doc = "< Other internal library failure"]
    pub const rocblas_status_internal_error: rocblas_status_ = rocblas_status_(6);
}
impl rocblas_status_ {
    #[doc = "< Performance degraded due to low device memory"]
    pub const rocblas_status_perf_degraded: rocblas_status_ = rocblas_status_(7);
}
impl rocblas_status_ {
    #[doc = "< Unmatched start/stop size query"]
    pub const rocblas_status_size_query_mismatch: rocblas_status_ = rocblas_status_(8);
}
impl rocblas_status_ {
    #[doc = "< Queried device memory size increased"]
    pub const rocblas_status_size_increased: rocblas_status_ = rocblas_status_(9);
}
impl rocblas_status_ {
    #[doc = "< Queried device memory size unchanged"]
    pub const rocblas_status_size_unchanged: rocblas_status_ = rocblas_status_(10);
}
impl rocblas_status_ {
    #[doc = "< Passed argument not valid"]
    pub const rocblas_status_invalid_value: rocblas_status_ = rocblas_status_(11);
}
impl rocblas_status_ {
    #[doc = "< Nothing preventing function to proceed"]
    pub const rocblas_status_continue: rocblas_status_ = rocblas_status_(12);
}
impl rocblas_status_ {
    pub const rocblas_status_check_numerics_fail: rocblas_status_ = rocblas_status_(13);
}
impl rocblas_status_ {
    pub const rocblas_status_excluded_from_build: rocblas_status_ = rocblas_status_(14);
}
impl rocblas_status_ {
    pub const rocblas_status_arch_mismatch: rocblas_status_ = rocblas_status_(15);
}
#[repr(transparent)]
#[doc = "   @brief rocblas status codes definition"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocblas_status_(pub ::std::os::raw::c_int);
#[doc = "   @brief rocblas status codes definition"]
pub use self::rocblas_status_ as rocblas_status;
pub type rocsolver_int = rocblas_int;
pub type rocsolver_handle = rocblas_handle;
#[doc = "   @brief rocblas status codes definition"]
pub use self::rocblas_status as rocsolver_status;
extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_create_handle."]
    pub fn rocsolver_create_handle(handle: *mut rocsolver_handle) -> rocsolver_status;
}
extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_destroy_handle."]
    pub fn rocsolver_destroy_handle(handle: rocsolver_handle) -> rocsolver_status;
}
extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_set_stream."]
    pub fn rocsolver_set_stream(handle: rocsolver_handle, stream: hipStream_t) -> rocsolver_status;
}
extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_get_stream."]
    pub fn rocsolver_get_stream(
        handle: rocsolver_handle,
        stream: *mut hipStream_t,
    ) -> rocsolver_status;
}
extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_set_vector."]
    pub fn rocsolver_set_vector(
        n: rocsolver_int,
        elem_size: rocsolver_int,
        x: *const ::std::os::raw::c_void,
        incx: rocsolver_int,
        y: *mut ::std::os::raw::c_void,
        incy: rocsolver_int,
    ) -> rocsolver_status;
}
extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_get_vector."]
    pub fn rocsolver_get_vector(
        n: rocsolver_int,
        elem_size: rocsolver_int,
        x: *const ::std::os::raw::c_void,
        incx: rocsolver_int,
        y: *mut ::std::os::raw::c_void,
        incy: rocsolver_int,
    ) -> rocsolver_status;
}
extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_set_matrix."]
    pub fn rocsolver_set_matrix(
        rows: rocsolver_int,
        cols: rocsolver_int,
        elem_size: rocsolver_int,
        a: *const ::std::os::raw::c_void,
        lda: rocsolver_int,
        b: *mut ::std::os::raw::c_void,
        ldb: rocsolver_int,
    ) -> rocsolver_status;
}
extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_get_matrix."]
    pub fn rocsolver_get_matrix(
        rows: rocsolver_int,
        cols: rocsolver_int,
        elem_size: rocsolver_int,
        a: *const ::std::os::raw::c_void,
        lda: rocsolver_int,
        b: *mut ::std::os::raw::c_void,
        ldb: rocsolver_int,
    ) -> rocsolver_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief GET_VERSION_STRING Queries the library version.\n\n\\details\n@param[out]\nbuf         A buffer that the version string will be written into.\n@param[in]\nlen         The size of the given buffer in bytes."]
    pub fn rocsolver_get_version_string(
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief GET_VERSION_STRING_SIZE Queries the minimum buffer size for a\nsuccessful call to \\ref rocsolver_get_version_string.\n\n\\details\n@param[out]\nlen         pointer to size_t.\nThe minimum length of buffer to pass to\n\\ref rocsolver_get_version_string."]
    pub fn rocsolver_get_version_string_size(len: *mut usize) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief LOG_BEGIN begins a rocSOLVER multi-level logging session.\n\n\\details\nInitializes the rocSOLVER logging environment with default values (no\nlogging and one level depth). Default mode can be overridden by using the\nenvironment variables ROCSOLVER_LAYER and ROCSOLVER_LEVELS.\n\nThis function also sets the streams where the log results will be outputted.\nThe default is STDERR for all the modes. This default can also be overridden\nusing the environment variable ROCSOLVER_LOG_PATH, or specifically\nROCSOLVER_LOG_TRACE_PATH, ROCSOLVER_LOG_BENCH_PATH, and/or ROCSOLVER_LOG_PROFILE_PATH."]
    pub fn rocsolver_log_begin() -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief LOG_END ends the multi-level rocSOLVER logging session.\n\n\\details\nIf applicable, this function also prints the profile logging results\nbefore cleaning the logging environment."]
    pub fn rocsolver_log_end() -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief LOG_SET_LAYER_MODE sets the logging mode for the rocSOLVER multi-level\nlogging environment.\n\n\\details\n@param[in]\nlayer_mode  rocblas_layer_mode_flags.\nSpecifies the logging mode."]
    pub fn rocsolver_log_set_layer_mode(layer_mode: rocblas_layer_mode_flags) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief LOG_SET_MAX_LEVELS sets the maximum trace log depth for the rocSOLVER\nmulti-level logging environment.\n\n\\details\n@param[in]\nmax_levels  rocblas_int. max_levels >= 1.\nSpecifies the maximum depth at which nested function calls\nwill appear in the trace and profile logs."]
    pub fn rocsolver_log_set_max_levels(max_levels: rocblas_int) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief LOG_RESTORE_DEFAULTS restores the default values of the rocSOLVER\nmulti-level logging environment.\n\n\\details\nThis function sets the logging mode and maximum trace log depth to their\ndefault values (no logging and one level depth)."]
    pub fn rocsolver_log_restore_defaults() -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief LOG_WRITE_PROFILE prints the profile logging results."]
    pub fn rocsolver_log_write_profile() -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief LOG_FLUSH_PROFILE prints the profile logging results and clears the\nprofile record."]
    pub fn rocsolver_log_flush_profile() -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LACGV conjugates the complex vector x.\n\n\\details\nIt conjugates the n entries of a complex vector x with increment incx.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe dimension of vector x.\n@param[inout]\nx           pointer to type. Array on the GPU of size at least n (size depends on the value of incx).\nOn entry, the vector x.\nOn exit, each entry is overwritten with its conjugate value.\n@param[in]\nincx        rocblas_int. incx != 0.\nThe distance between two consecutive elements of x.\nIf incx is negative, the elements of x are indexed in\nreverse order."]
    pub fn rocsolver_clacgv(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlacgv(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LASWP performs a series of row interchanges on the matrix A.\n\n\\details\nRow interchanges are done one by one. If \\f$\\text{ipiv}[k_1 + (j - k_1) \\cdot \\text{abs}(\\text{incx})] = r\\f$, then the j-th row of A\nwill be interchanged with the r-th row of A, for \\f$j = k_1,k_1+1,\\dots,k_2\\f$. Indices \\f$k_1\\f$ and \\f$k_2\\f$ are 1-based indices.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to which the row\ninterchanges will be applied. On exit, the resulting permuted matrix.\n@param[in]\nlda         rocblas_int. lda > 0.\nThe leading dimension of the array A.\n@param[in]\nk1          rocblas_int. k1 > 0.\nThe k_1 index. It is the first element of ipiv for which a row interchange will\nbe done. This is a 1-based index.\n@param[in]\nk2          rocblas_int. k2 > k1 > 0.\nThe k_2 index. k_2 - k_1 + 1 is the number of elements of ipiv for which a row\ninterchange will be done. This is a 1-based index.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU of dimension at least \\f$k_1 + (k_2 - k_1)\\cdot \\text{abs}(\\text{incx})\\f$.\nThe vector of pivot indices. Only the elements in positions\n\\f$k_1\\f$ through \\f$k_1 + (k_2 - k_1)\\cdot \\text{abs}(\\text{incx})\\f$ of this vector are accessed.\nElements of ipiv are considered 1-based.\n@param[in]\nincx        rocblas_int. incx != 0.\nThe distance between successive values of ipiv.  If incx\nis negative, the pivots are applied in reverse order."]
    pub fn rocsolver_slaswp(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        k1: rocblas_int,
        k2: rocblas_int,
        ipiv: *const rocblas_int,
        incx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlaswp(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        k1: rocblas_int,
        k2: rocblas_int,
        ipiv: *const rocblas_int,
        incx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_claswp(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        k1: rocblas_int,
        k2: rocblas_int,
        ipiv: *const rocblas_int,
        incx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlaswp(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        k1: rocblas_int,
        k2: rocblas_int,
        ipiv: *const rocblas_int,
        incx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LARFG generates a Householder reflector H of order n.\n\n\\details\nThe reflector H is such that\n\n\\f[\nH'\\left[\\begin{array}{c}\n\\text{alpha}\\\\\nx\n\\end{array}\\right]=\\left[\\begin{array}{c}\n\\text{beta}\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere x is an n-1 vector, and alpha and beta are scalars. Matrix H can be\ngenerated as\n\n\\f[\nH = I - \\text{tau}\\left[\\begin{array}{c}\n1\\\\\nv\n\\end{array}\\right]\\left[\\begin{array}{cc}\n1 & v'\n\\end{array}\\right]\n\\f]\n\nwhere v is an n-1 vector, and tau is a scalar known as the Householder scalar. The vector\n\n\\f[\n\\bar{v}=\\left[\\begin{array}{c}\n1\\\\\nv\n\\end{array}\\right]\n\\f]\n\nis the Householder vector associated with the reflection.\n\n\\note\nThe matrix H is orthogonal/unitary (i.e. \\f$H'H=HH'=I\\f$). It is symmetric when real (i.e. \\f$H^T=H\\f$), but not Hermitian when complex\n(i.e. \\f$H^H\\neq H\\f$ in general).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order (size) of reflector H.\n@param[inout]\nalpha       pointer to type. A scalar on the GPU.\nOn entry, the scalar alpha.\nOn exit, it is overwritten with beta.\n@param[inout]\nx           pointer to type. Array on the GPU of size at least n-1 (size depends on the value of incx).\nOn entry, the vector x,\nOn exit, it is overwritten with vector v.\n@param[in]\nincx        rocblas_int. incx > 0.\nThe distance between two consecutive elements of x.\n@param[out]\ntau         pointer to type. A scalar on the GPU.\nThe Householder scalar tau."]
    pub fn rocsolver_slarfg(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *mut f32,
        x: *mut f32,
        incx: rocblas_int,
        tau: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlarfg(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *mut f64,
        x: *mut f64,
        incx: rocblas_int,
        tau: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_clarfg(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *mut rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        tau: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlarfg(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *mut rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        tau: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LARFT generates the triangular factor T of a block reflector H of\norder n.\n\n\\details\nThe block reflector H is defined as the product of k Householder matrices\n\n\\f[\n\\begin{array}{cl}\nH = H(1)H(2)\\cdots H(k) & \\: \\text{if direct indicates forward direction, or} \\\\\nH = H(k)\\cdots H(2)H(1) & \\: \\text{if direct indicates backward direction}\n\\end{array}\n\\f]\n\nThe triangular factor T is upper triangular in the forward direction and lower triangular in the backward direction.\nIf storev is column-wise, then\n\n\\f[\nH = I - VTV'\n\\f]\n\nwhere the \\f$j\\f$th column of matrix V contains the Householder vector associated with \\f$H(j)\\f$. If storev is row-wise, then\n\n\\f[\nH = I - V'TV\n\\f]\n\nwhere the \\f$i\\f$th row of matrix V contains the Householder vector associated with \\f$H(i)\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ndirect      #rocblas_direct.\nSpecifies the direction in which the Householder matrices are applied.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies how the Householder vectors are stored in matrix V.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order (size) of the block reflector.\n@param[in]\nk           rocblas_int. k >= 1.\nThe number of Householder matrices forming H.\n@param[in]\nV           pointer to type. Array on the GPU of size ldv*k if column-wise, or ldv*n if row-wise.\nThe matrix of Householder vectors.\n@param[in]\nldv         rocblas_int. ldv >= n if column-wise, or ldv >= k if row-wise.\nLeading dimension of V.\n@param[in]\ntau         pointer to type. Array of k scalars on the GPU.\nThe vector of all the Householder scalars.\n@param[out]\nT           pointer to type. Array on the GPU of dimension ldt*k.\nThe triangular factor. T is upper triangular if direct indicates forward direction, otherwise it is\nlower triangular. The rest of the array is not used.\n@param[in]\nldt         rocblas_int. ldt >= k.\nThe leading dimension of T."]
    pub fn rocsolver_slarft(
        handle: rocblas_handle,
        direct: rocblas_direct,
        storev: rocblas_storev,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        tau: *mut f32,
        T: *mut f32,
        ldt: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlarft(
        handle: rocblas_handle,
        direct: rocblas_direct,
        storev: rocblas_storev,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        tau: *mut f64,
        T: *mut f64,
        ldt: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_clarft(
        handle: rocblas_handle,
        direct: rocblas_direct,
        storev: rocblas_storev,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        tau: *mut rocblas_float_complex,
        T: *mut rocblas_float_complex,
        ldt: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlarft(
        handle: rocblas_handle,
        direct: rocblas_direct,
        storev: rocblas_storev,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        tau: *mut rocblas_double_complex,
        T: *mut rocblas_double_complex,
        ldt: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LARF applies a Householder reflector H to a general matrix A.\n\n\\details\nThe Householder reflector H, of order m or n, is to be applied to an m-by-n matrix A\nfrom the left or the right, depending on the value of side. H is given by\n\n\\f[\nH = I - \\text{alpha}\\cdot xx'\n\\f]\n\nwhere alpha is the Householder scalar and x is a Householder vector. H is never actually computed.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nDetermines whether H is applied from the left or the right.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of A.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of A.\n@param[in]\nx           pointer to type. Array on the GPU of size at least 1 + (m-1)*abs(incx) if left side, or\nat least 1 + (n-1)*abs(incx) if right side.\nThe Householder vector x.\n@param[in]\nincx        rocblas_int. incx != 0.\nDistance between two consecutive elements of x.\nIf incx < 0, the elements of x are indexed in reverse order.\n@param[in]\nalpha       pointer to type. A scalar on the GPU.\nThe Householder scalar. If alpha = 0, then H = I (A will remain the same; x is never used)\n@param[inout]\nA           pointer to type. Array on the GPU of size lda*n.\nOn entry, the matrix A. On exit, it is overwritten with\nH*A (or A*H).\n@param[in]\nlda         rocblas_int. lda >= m.\nLeading dimension of A."]
    pub fn rocsolver_slarf(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
        alpha: *const f32,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlarf(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
        alpha: *const f64,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_clarf(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlarf(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LARFB applies a block reflector H to a general m-by-n matrix A.\n\n\\details\nThe block reflector H is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nHA & \\: \\text{(No transpose from the left),}\\\\\nH'A & \\:  \\text{(Transpose or conjugate transpose from the left),}\\\\\nAH & \\: \\text{(No transpose from the right), or}\\\\\nAH' & \\: \\text{(Transpose or conjugate transpose from the right).}\n\\end{array}\n\\f]\n\nThe block reflector H is defined as the product of k Householder matrices as\n\n\\f[\n\\begin{array}{cl}\nH = H(1)H(2)\\cdots H(k) & \\: \\text{if direct indicates forward direction, or} \\\\\nH = H(k)\\cdots H(2)H(1) & \\: \\text{if direct indicates backward direction}\n\\end{array}\n\\f]\n\nH is never stored. It is calculated as\n\n\\f[\nH = I - VTV'\n\\f]\n\nwhere the \\f$j\\f$th column of matrix V contains the Householder vector associated with \\f$H(j)\\f$, if storev is column-wise; or\n\n\\f[\nH = I - V'TV\n\\f]\n\nwhere the \\f$i\\f$th row of matrix V contains the Householder vector associated with \\f$H(i)\\f$, if storev is row-wise.\nT is the associated triangular factor as computed by \\ref rocsolver_slarft \"LARFT\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply H.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the block reflector or its transpose/conjugate transpose is to be applied.\n@param[in]\ndirect      #rocblas_direct.\nSpecifies the direction in which the Householder matrices are to be applied to generate H.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies how the Householder vectors are stored in matrix V.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix A.\n@param[in]\nk           rocblas_int. k >= 1.\nThe number of Householder matrices.\n@param[in]\nV           pointer to type. Array on the GPU of size ldv*k if column-wise, ldv*n if row-wise and applying from the right,\nor ldv*m if row-wise and applying from the left.\nThe matrix of Householder vectors.\n@param[in]\nldv         rocblas_int. ldv >= k if row-wise, ldv >= m if column-wise and applying from the left, or ldv >= n if\ncolumn-wise and applying from the right.\nLeading dimension of V.\n@param[in]\nT           pointer to type. Array on the GPU of dimension ldt*k.\nThe triangular factor of the block reflector.\n@param[in]\nldt         rocblas_int. ldt >= k.\nThe leading dimension of T.\n@param[inout]\nA           pointer to type. Array on the GPU of size lda*n.\nOn entry, the matrix A. On exit, it is overwritten with\nH*A, A*H, H'*A, or A*H'.\n@param[in]\nlda         rocblas_int. lda >= m.\nLeading dimension of A."]
    pub fn rocsolver_slarfb(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        direct: rocblas_direct,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        T: *mut f32,
        ldt: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlarfb(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        direct: rocblas_direct,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        T: *mut f64,
        ldt: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_clarfb(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        direct: rocblas_direct,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        T: *mut rocblas_float_complex,
        ldt: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlarfb(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        direct: rocblas_direct,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        T: *mut rocblas_double_complex,
        ldt: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LABRD computes the bidiagonal form of the first k rows and columns of\na general m-by-n matrix A, as well as the matrices X and Y needed to reduce\nthe remaining part of A.\n\n\\details\nThe reduced form is given by:\n\n\\f[\nB = Q'AP\n\\f]\n\nwhere the leading k-by-k block of B is upper bidiagonal if m >= n, or lower bidiagonal if m < n. Q and\nP are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(k), & \\text{and} \\\\\nP = G(1)G(2)\\cdots G(k).\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ and \\f$G(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH(i) = I - \\text{tauq}[i]\\cdot v_i^{}v_i', & \\text{and} \\\\\nG(i) = I - \\text{taup}[i]\\cdot u_i^{}u_i'.\n\\end{array}\n\\f]\n\nIf m >= n, the first \\f$i-1\\f$ elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i]=1\\f$;\nwhile the first \\f$i\\f$ elements of the Householder vector \\f$u_i\\f$ are zero, and  \\f$u_i[i+1]=1\\f$.\nIf m < n, the first \\f$i\\f$ elements of the Householder vector  \\f$v_i\\f$ are zero, and  \\f$v_i[i+1]=1\\f$;\nwhile the first \\f$i-1\\f$ elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i]=1\\f$.\n\nThe unreduced part of the matrix A can be updated using the block update\n\n\\f[\nA = A - VY' - XU'\n\\f]\n\nwhere V and U are the m-by-k and n-by-k matrices formed with the vectors \\f$v_i\\f$ and \\f$u_i\\f$, respectively.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[in]\nk           rocblas_int. min(m,n) >= k >= 0.\nThe number of leading rows and columns of matrix A that will be reduced.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be reduced.\nOn exit, the first k elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n), contain the bidiagonal form B.\nIf m >= n, the elements below the diagonal of the first k columns are the possibly non-zero elements\nof the Householder vectors associated with Q, while the elements above the\nsuperdiagonal of the first k rows are the n - i - 1 possibly non-zero elements of the Householder vectors related to P.\nIf m < n, the elements below the subdiagonal of the first k columns are the m - i - 1 possibly non-zero\nelements of the Householder vectors related to Q, while the elements above the\ndiagonal of the first k rows are the n - i possibly non-zero elements of the vectors associated with P.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension k.\nThe diagonal elements of B.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension k.\nThe off-diagonal elements of B.\n@param[out]\ntauq        pointer to type. Array on the GPU of dimension k.\nThe Householder scalars associated with matrix Q.\n@param[out]\ntaup        pointer to type. Array on the GPU of dimension k.\nThe Householder scalars associated with matrix P.\n@param[out]\nX           pointer to type. Array on the GPU of dimension ldx*k.\nThe m-by-k matrix needed to update the unreduced part of A.\n@param[in]\nldx         rocblas_int. ldx >= m.\nThe leading dimension of X.\n@param[out]\nY           pointer to type. Array on the GPU of dimension ldy*k.\nThe n-by-k matrix needed to update the unreduced part of A.\n@param[in]\nldy         rocblas_int. ldy >= n.\nThe leading dimension of Y."]
    pub fn rocsolver_slabrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
        X: *mut f32,
        ldx: rocblas_int,
        Y: *mut f32,
        ldy: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlabrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
        X: *mut f64,
        ldx: rocblas_int,
        Y: *mut f64,
        ldy: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_clabrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut rocblas_float_complex,
        taup: *mut rocblas_float_complex,
        X: *mut rocblas_float_complex,
        ldx: rocblas_int,
        Y: *mut rocblas_float_complex,
        ldy: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlabrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut rocblas_double_complex,
        taup: *mut rocblas_double_complex,
        X: *mut rocblas_double_complex,
        ldx: rocblas_int,
        Y: *mut rocblas_double_complex,
        ldy: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LATRD computes the tridiagonal form of k rows and columns of\na symmetric/hermitian matrix A, as well as the matrix W needed to update\nthe remaining part of A.\n\n\\details\nThe reduced form is given by:\n\n\\f[\nT = Q'AQ\n\\f]\n\nIf uplo is lower, the first k rows and columns of T form the tridiagonal block. If uplo is upper, then the last\nk rows and columns of T form the tridiagonal block. Q is an orthogonal/unitary matrix represented as the\nproduct of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(k) & \\text{if uplo indicates lower, or}\\\\\nQ = H(n)H(n-1)\\cdots H(n-k+1) & \\text{if uplo is upper}.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i]\\cdot v_i^{}v_i'\n\\f]\n\nwhere tau[\\f$i\\f$] is the corresponding Householder scalar. When uplo indicates lower, the first \\f$i\\f$\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo is upper,\nthe last n-\\f$i\\f$ elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\nThe unreduced part of the matrix A can be updated using a rank update of the form:\n\n\\f[\nA = A - VW' - WV'\n\\f]\n\nwhere V is the n-by-k matrix formed by the vectors \\f$v_i\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of rows and columns of the matrix A to be reduced.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the n-by-n matrix to be reduced.\nOn exit, if uplo is lower, the first k columns have been reduced to tridiagonal form\n(given in the diagonal elements of A and the array E), the elements below the diagonal\ncontain the possibly non-zero entries of the Householder vectors associated with Q, stored as columns.\nIf uplo is upper, the last k columns have been reduced to tridiagonal form\n(given in the diagonal elements of A and the array E), the elements above the diagonal\ncontain the possibly non-zero entries of the Householder vectors associated with Q, stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n-1.\nIf upper (lower), the last (first) k elements of E are the off-diagonal elements of the\ncomputed tridiagonal block.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nIf upper (lower), the last (first) k elements of tau are the Householder scalars related to Q.\n@param[out]\nW           pointer to type. Array on the GPU of dimension ldw*k.\nThe n-by-k matrix needed to update the unreduced part of A.\n@param[in]\nldw         rocblas_int. ldw >= n.\nThe leading dimension of W."]
    pub fn rocsolver_slatrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        E: *mut f32,
        tau: *mut f32,
        W: *mut f32,
        ldw: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlatrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        E: *mut f64,
        tau: *mut f64,
        W: *mut f64,
        ldw: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_clatrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        E: *mut f32,
        tau: *mut rocblas_float_complex,
        W: *mut rocblas_float_complex,
        ldw: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlatrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        E: *mut f64,
        tau: *mut rocblas_double_complex,
        W: *mut rocblas_double_complex,
        ldw: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LASYF computes a partial factorization of a symmetric matrix \\f$A\\f$\nusing Bunch-Kaufman diagonal pivoting.\n\n\\details\nThe partial factorization has the form\n\n\\f[\nA = \\left[ \\begin{array}{cc}\nI & U_{12} \\\\\n0 & U_{22}\n\\end{array} \\right] \\left[ \\begin{array}{cc}\nA_{11} & 0 \\\\\n0 & D\n\\end{array} \\right] \\left[ \\begin{array}{cc}\nI & 0 \\\\\nU_{12}^T & U_{22}^T\n\\end{array} \\right]\n\\f]\n\nor\n\n\\f[\nA = \\left[ \\begin{array}{cc}\nL_{11} & 0 \\\\\nL_{21} & I\n\\end{array} \\right] \\left[ \\begin{array}{cc}\nD & 0 \\\\\n0 & A_{22}\n\\end{array} \\right] \\left[ \\begin{array}{cc}\nL_{11}^T & L_{21}^T \\\\\n0 & I\n\\end{array} \\right]\n\\f]\n\ndepending on the value of uplo. The order of the block diagonal matrix \\f$D\\f$\nis either \\f$nb\\f$ or \\f$nb-1\\f$, and is returned in the argument \\f$kb\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[in]\nnb          rocblas_int. 2 <= nb <= n.\nThe number of columns of A to be factored.\n@param[out]\nkb          pointer to a rocblas_int on the GPU.\nThe number of columns of A that were actually factored (either nb or\nnb-1).\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A to be factored.\nOn exit, the partially factored matrix.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nIf uplo is upper, then only the last kb elements of ipiv will be\nset. For n - kb < k <= n, if ipiv[k] > 0 then rows and columns k\nand ipiv[k] were interchanged and D[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv[k] = ipiv[k-1] < 0, then rows and columns k-1\nand -ipiv[k] were interchanged and D[k-1,k-1] to D[k,k] is a 2-by-2\ndiagonal block.\nIf uplo is lower, then only the first kb elements of ipiv will be\nset. For 1 <= k <= kb, if ipiv[k] > 0 then rows and columns k\nand ipiv[k] were interchanged and D[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv[k] = ipiv[k+1] < 0, then rows and columns k+1\nand -ipiv[k] were interchanged and D[k,k] to D[k+1,k+1] is a 2-by-2\ndiagonal block.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, D is singular. D[i,i] is the first diagonal zero."]
    pub fn rocsolver_slasyf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nb: rocblas_int,
        kb: *mut rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlasyf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nb: rocblas_int,
        kb: *mut rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_clasyf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nb: rocblas_int,
        kb: *mut rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlasyf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nb: rocblas_int,
        kb: *mut rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief LAUUM computes the product of the upper (or lower) triangular part U (or L) of a\nsymmetric/Hemitian matrix A with its transpose.\n\n\\details\nIf uplo indicates upper, then \\f$UU'\\f$ is computed. If uplo indicates lower, then \\f$L'L\\f$ is computed instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower triangular part of A will be used.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not referenced.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns and rows of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, it contains the upper (or lower) part of the symmetric/Hermitian matrix.\nOn exit, the upper (or lower) part is overwritten with the result of U*U' (or L'*L).\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of the array A."]
    pub fn rocsolver_slauum(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dlauum(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_clauum(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zlauum(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORG2R generates an m-by-n Matrix Q with orthonormal columns.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the first n columns of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k).\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQRF\", with the Householder vectors in the first k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\"."]
    pub fn rocsolver_sorg2r(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorg2r(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNG2R generates an m-by-n complex Matrix Q with orthonormal columns.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the first n columns of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQRF\", with the Householder vectors in the first k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\"."]
    pub fn rocsolver_cung2r(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zung2r(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORGQR generates an m-by-n Matrix Q with orthonormal columns.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the first n columns of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQRF\", with the Householder vectors in the first k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\"."]
    pub fn rocsolver_sorgqr(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorgqr(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNGQR generates an m-by-n complex Matrix Q with orthonormal columns.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the first n columns of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nHouseholder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQRF\", with the Householder vectors in the first k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\"."]
    pub fn rocsolver_cungqr(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zungqr(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORGL2 generates an m-by-n Matrix Q with orthonormal rows.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the first m rows of the product of k Householder\nreflectors of order n\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. 0 <= m <= n.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= m.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GELQF\", with the Householder vectors in the first k rows.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\"."]
    pub fn rocsolver_sorgl2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorgl2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNGL2 generates an m-by-n complex Matrix Q with orthonormal rows.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the first m rows of the product of k Householder\nreflectors of order n\n\n\\f[\nQ = H(k)^HH(k-1)^H\\cdots H(1)^H\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. 0 <= m <= n.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= m.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GELQF\", with the Householder vectors in the first k rows.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\"."]
    pub fn rocsolver_cungl2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zungl2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORGLQ generates an m-by-n Matrix Q with orthonormal rows.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the first m rows of the product of k Householder\nreflectors of order n\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. 0 <= m <= n.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= m.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GELQF\", with the Householder vectors in the first k rows.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\"."]
    pub fn rocsolver_sorglq(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorglq(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNGLQ generates an m-by-n complex Matrix Q with orthonormal rows.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the first m rows of the product of k Householder\nreflectors of order n\n\n\\f[\nQ = H(k)^HH(k-1)^H\\cdots H(1)^H\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. 0 <= m <= n.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= m.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GELQF\", with the Householder vectors in the first k rows.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\"."]
    pub fn rocsolver_cunglq(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunglq(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORG2L generates an m-by-n Matrix Q with orthonormal columns.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the last n columns of the product of k\nHouseholder reflectors of order m\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQLF\", with the Householder vectors in the last k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqlf \"GEQLF\"."]
    pub fn rocsolver_sorg2l(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorg2l(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNG2L generates an m-by-n complex Matrix Q with orthonormal columns.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the last n columns of the product of k\nHouseholder reflectors of order m\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQLF\", with the Householder vectors in the last k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqlf \"GEQLF\"."]
    pub fn rocsolver_cung2l(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zung2l(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORGQL generates an m-by-n Matrix Q with orthonormal columns.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the last n column of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQLF\", with the Householder vectors in the last k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqlf \"GEQLF\"."]
    pub fn rocsolver_sorgql(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorgql(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNGQL generates an m-by-n complex Matrix Q with orthonormal columns.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the last n columns of the product of k\nHouseholder reflectors of order m\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQLF\", with the Householder vectors in the last k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqlf \"GEQLF\"."]
    pub fn rocsolver_cungql(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zungql(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORGBR generates an m-by-n Matrix Q with orthonormal rows or columns.\n\n\\details\nIf storev is column-wise, then the matrix Q has orthonormal columns. If m >= k, Q is defined as the first\nn columns of the product of k Householder reflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nIf m < k, Q is defined as the product of Householder reflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(m-1)\n\\f]\n\nOn the other hand, if storev is row-wise, then the matrix Q has orthonormal rows. If n > k, Q is defined as the\nfirst m rows of the product of k Householder reflectors of order n\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nIf n <= k, Q is defined as the product of Householder reflectors of order n\n\n\\f[\nQ = H(n-1)H(n-2)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgebrd \"GEBRD\" in its arguments A and tauq or taup.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies whether to work column-wise or row-wise.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\nIf row-wise, then min(n,k) <= m <= n.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\nIf column-wise, then min(m,k) <= n <= m.\n@param[in]\nk           rocblas_int. k >= 0.\nThe number of columns (if storev is column-wise) or rows (if row-wise) of the\noriginal matrix reduced by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the Householder vectors as returned by \\ref rocsolver_sgebrd \"GEBRD\".\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension min(m,k) if column-wise, or min(n,k) if row-wise.\nThe Householder scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\"."]
    pub fn rocsolver_sorgbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorgbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNGBR generates an m-by-n complex Matrix Q with orthonormal rows or\ncolumns.\n\n\\details\nIf storev is column-wise, then the matrix Q has orthonormal columns. If m >= k, Q is defined as the first\nn columns of the product of k Householder reflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nIf m < k, Q is defined as the product of Householder reflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(m-1)\n\\f]\n\nOn the other hand, if storev is row-wise, then the matrix Q has orthonormal rows. If n > k, Q is defined as the\nfirst m rows of the product of k Householder reflectors of order n\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nIf n <= k, Q is defined as the product of Householder reflectors of order n\n\n\\f[\nQ = H(n-1)H(n-2)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgebrd \"GEBRD\" in its arguments A and tauq or taup.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies whether to work column-wise or row-wise.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\nIf row-wise, then min(n,k) <= m <= n.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\nIf column-wise, then min(m,k) <= n <= m.\n@param[in]\nk           rocblas_int. k >= 0.\nThe number of columns (if storev is column-wise) or rows (if row-wise) of the\noriginal matrix reduced by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the Householder vectors as returned by \\ref rocsolver_sgebrd \"GEBRD\".\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension min(m,k) if column-wise, or min(n,k) if row-wise.\nThe Householder scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\"."]
    pub fn rocsolver_cungbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zungbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORGTR generates an n-by-n orthogonal Matrix Q.\n\n\\details\nQ is defined as the product of n-1 Householder reflectors of order n. If\nuplo indicates upper, then Q has the form\n\n\\f[\nQ = H(n-1)H(n-2)\\cdots H(1)\n\\f]\n\nOn the other hand, if uplo indicates lower, then Q has the form\n\n\\f[\nQ = H(1)H(2)\\cdots H(n-1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by\n\\ref rocsolver_ssytrd \"SYTRD\" in its arguments A and tau.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the \\ref rocsolver_ssytrd \"SYTRD\" factorization was upper or lower\ntriangular. If uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix Q.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the Householder vectors as returned\nby \\ref rocsolver_ssytrd \"SYTRD\". On exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars as returned by \\ref rocsolver_ssytrd \"SYTRD\"."]
    pub fn rocsolver_sorgtr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorgtr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNGTR generates an n-by-n unitary Matrix Q.\n\n\\details\nQ is defined as the product of n-1 Householder reflectors of order n. If\nuplo indicates upper, then Q has the form\n\n\\f[\nQ = H(n-1)H(n-2)\\cdots H(1)\n\\f]\n\nOn the other hand, if uplo indicates lower, then Q has the form\n\n\\f[\nQ = H(1)H(2)\\cdots H(n-1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by\n\\ref rocsolver_chetrd \"HETRD\" in its arguments A and tau.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the \\ref rocsolver_chetrd \"HETRD\" factorization was upper or lower\ntriangular. If uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix Q.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the Householder vectors as returned\nby \\ref rocsolver_chetrd \"HETRD\". On exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars as returned by \\ref rocsolver_chetrd \"HETRD\"."]
    pub fn rocsolver_cungtr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zungtr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORM2R multiplies a matrix Q with orthonormal columns by a general m-by-n\nmatrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2) \\cdots H(k)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the QR factorization \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqrf \"GEQRF\"\nin the first k columns of its argument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sorm2r(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorm2r(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNM2R multiplies a complex matrix Q with orthonormal columns by a\ngeneral m-by-n matrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the QR factorization \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqrf \"GEQRF\"\nin the first k columns of its argument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C.\n"]
    pub fn rocsolver_cunm2r(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunm2r(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORMQR multiplies a matrix Q with orthonormal columns by a general m-by-n\nmatrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the QR factorization \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqrf \"GEQRF\"\nin the first k columns of its argument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormqr(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dormqr(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNMQR multiplies a complex matrix Q with orthonormal columns by a\ngeneral m-by-n matrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the QR factorization \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqrf \"GEQRF\"\nin the first k columns of its argument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmqr(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunmqr(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORML2 multiplies a matrix Q with orthonormal rows by a general m-by-n\nmatrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the LQ factorization \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*m if side is left, or lda*n if side is right.\nThe Householder vectors as returned by \\ref rocsolver_sgelqf \"GELQF\"\nin the first k rows of its argument A.\n@param[in]\nlda         rocblas_int. lda >= k.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C.\n"]
    pub fn rocsolver_sorml2(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorml2(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNML2 multiplies a complex matrix Q with orthonormal rows by a general\nm-by-n matrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)^HH(k-1)^H\\cdots H(1)^H\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the LQ factorization \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*m if side is left, or lda*n if side is right.\nThe Householder vectors as returned by \\ref rocsolver_sgelqf \"GELQF\"\nin the first k rows of its argument A.\n@param[in]\nlda         rocblas_int. lda >= k.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunml2(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunml2(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORMLQ multiplies a matrix Q with orthonormal rows by a general m-by-n\nmatrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the LQ factorization \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*m if side is left, or lda*n if side is right.\nThe Householder vectors as returned by \\ref rocsolver_sgelqf \"GELQF\"\nin the first k rows of its argument A.\n@param[in]\nlda         rocblas_int. lda >= k.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormlq(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dormlq(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNMLQ multiplies a complex matrix Q with orthonormal rows by a general\nm-by-n matrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)^HH(k-1)^H\\cdots H(1)^H\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the LQ factorization \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*m if side is left, or lda*n if side is right.\nThe Householder vectors as returned by \\ref rocsolver_sgelqf \"GELQF\"\nin the first k rows of its argument A.\n@param[in]\nlda         rocblas_int. lda >= k.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmlq(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunmlq(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORM2L multiplies a matrix Q with orthonormal columns by a general m-by-n\nmatrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is\nnever stored, it is calculated from the Householder vectors and scalars\nreturned by the QL factorization \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be\napplied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqlf \"GEQLF\" in the last k columns of its\nargument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by\n\\ref rocsolver_sgeqlf \"GEQLF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sorm2l(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dorm2l(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNM2L multiplies a complex matrix Q with orthonormal columns by a\ngeneral m-by-n matrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is\nnever stored, it is calculated from the Householder vectors and scalars\nreturned by the QL factorization \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate\ntranspose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqlf \"GEQLF\" in the last k columns of its\nargument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by\n\\ref rocsolver_sgeqlf \"GEQLF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunm2l(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunm2l(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORMQL multiplies a matrix Q with orthonormal columns by a general m-by-n\nmatrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is\nnever stored, it is calculated from the Householder vectors and scalars\nreturned by the QL factorization \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be\napplied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqlf \"GEQLF\" in the last k columns of its\nargument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by\n\\ref rocsolver_sgeqlf \"GEQLF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormql(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dormql(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNMQL multiplies a complex matrix Q with orthonormal columns by a\ngeneral m-by-n matrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is\nnever stored, it is calculated from the Householder vectors and scalars\nreturned by the QL factorization \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate\ntranspose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqlf \"GEQLF\" in the last k columns of its\nargument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by\n\\ref rocsolver_sgeqlf \"GEQLF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmql(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunmql(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORMBR multiplies a matrix Q with orthonormal rows or columns by a\ngeneral m-by-n matrix C.\n\n\\details\nIf storev is column-wise, then the matrix Q has orthonormal columns.\nIf storev is row-wise, then the matrix Q has orthonormal rows.\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nThe order q of the orthogonal matrix Q is q = m if applying from the left, or q = n if applying from the right.\n\nWhen storev is column-wise, if q >= k, then Q is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k),\n\\f]\n\nand if q < k, then Q is defined as the product\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1).\n\\f]\n\nWhen storev is row-wise, if q > k, then Q is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k),\n\\f]\n\nand if q <= k, Q is defined as the product\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1).\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors and scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\" in its arguments A and tauq or taup.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies whether to work column-wise or row-wise.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0.\nThe number of columns (if storev is column-wise) or rows (if row-wise) of the\noriginal matrix reduced by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[in]\nA           pointer to type. Array on the GPU of size lda*min(q,k) if column-wise, or lda*q if row-wise.\nThe Householder vectors as returned by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[in]\nlda         rocblas_int. lda >= q if column-wise, or lda >= min(q,k) if row-wise.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least min(q,k).\nThe Householder scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dormbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNMBR multiplies a complex matrix Q with orthonormal rows or columns by\na general m-by-n matrix C.\n\n\\details\nIf storev is column-wise, then the matrix Q has orthonormal columns.\nIf storev is row-wise, then the matrix Q has orthonormal rows.\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nThe order q of the unitary matrix Q is q = m if applying from the left, or q = n if applying from the right.\n\nWhen storev is column-wise, if q >= k, then Q is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k),\n\\f]\n\nand if q < k, then Q is defined as the product\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1).\n\\f]\n\nWhen storev is row-wise, if q > k, then Q is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k),\n\\f]\n\nand if q <= k, Q is defined as the product\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1).\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors and scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\" in its arguments A and tauq or taup.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies whether to work column-wise or row-wise.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0.\nThe number of columns (if storev is column-wise) or rows (if row-wise) of the\noriginal matrix reduced by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[in]\nA           pointer to type. Array on the GPU of size lda*min(q,k) if column-wise, or lda*q if row-wise.\nThe Householder vectors as returned by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[in]\nlda         rocblas_int. lda >= q if column-wise, or lda >= min(q,k) if row-wise.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least min(q,k).\nThe Householder scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunmbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief ORMTR multiplies an orthogonal matrix Q by a general m-by-n matrix C.\n\n\\details\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nThe order q of the orthogonal matrix Q is q = m if applying from the left, or\nq = n if applying from the right.\n\nQ is defined as a product of q-1 Householder reflectors. If\nuplo indicates upper, then Q has the form\n\n\\f[\nQ = H(q-1)H(q-2)\\cdots H(1).\n\\f]\n\nOn the other hand, if uplo indicates lower, then Q has the form\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors and scalars as returned by\n\\ref rocsolver_ssytrd \"SYTRD\" in its arguments A and tau.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the \\ref rocsolver_ssytrd \"SYTRD\" factorization was upper or\nlower triangular. If uplo indicates lower (or upper), then the upper (or\nlower) part of A is not used.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be\napplied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*q.\nOn entry, the Householder vectors as\nreturned by \\ref rocsolver_ssytrd \"SYTRD\".\n@param[in]\nlda         rocblas_int. lda >= q.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least q-1.\nThe Householder scalars as returned by\n\\ref rocsolver_ssytrd \"SYTRD\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormtr(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dormtr(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief UNMTR multiplies a unitary matrix Q by a general m-by-n matrix C.\n\n\\details\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nThe order q of the unitary matrix Q is q = m if applying from the left, or\nq = n if applying from the right.\n\nQ is defined as a product of q-1 Householder reflectors. If\nuplo indicates upper, then Q has the form\n\n\\f[\nQ = H(q-1)H(q-2)\\cdots H(1).\n\\f]\n\nOn the other hand, if uplo indicates lower, then Q has the form\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors and scalars as returned by\n\\ref rocsolver_chetrd \"HETRD\" in its arguments A and tau.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the \\ref rocsolver_chetrd \"HETRD\" factorization was upper or\nlower triangular. If uplo indicates lower (or upper), then the upper (or\nlower) part of A is not used.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate\ntranspose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*q.\nOn entry, the Householder vectors as\nreturned by \\ref rocsolver_chetrd \"HETRD\".\n@param[in]\nlda         rocblas_int. lda >= q.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least q-1.\nThe Householder scalars as returned by\n\\ref rocsolver_chetrd \"HETRD\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmtr(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zunmtr(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief BDSQR computes the singular value decomposition (SVD) of an\nn-by-n bidiagonal matrix B, using the implicit QR algorithm.\n\n\\details\nThe SVD of B has the form:\n\n\\f[\nB = QSP'\n\\f]\n\nwhere S is the n-by-n diagonal matrix of singular values of B, the columns of Q are the left\nsingular vectors of B, and the columns of P are its right singular vectors.\n\nThe computation of the singular vectors is optional; this function accepts input matrices\nU (of size nu-by-n) and V (of size n-by-nv) that are overwritten with \\f$UQ\\f$ and \\f$P'V\\f$. If nu = 0\nno left vectors are computed; if nv = 0 no right vectors are computed.\n\nOptionally, this function can also compute \\f$Q'C\\f$ for a given n-by-nc input matrix C.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether B is upper or lower bidiagonal.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix B.\n@param[in]\nnv          rocblas_int. nv >= 0.\nThe number of columns of matrix V.\n@param[in]\nnu          rocblas_int. nu >= 0.\nThe number of rows of matrix U.\n@param[in]\nnc          rocblas_int. nu >= 0.\nThe number of columns of matrix C.\n@param[inout]\nD           pointer to real type. Array on the GPU of dimension n.\nOn entry, the diagonal elements of B. On exit, if info = 0,\nthe singular values of B in decreasing order; if info > 0,\nthe diagonal elements of a bidiagonal matrix\northogonally equivalent to B.\n@param[inout]\nE           pointer to real type. Array on the GPU of dimension n-1.\nOn entry, the off-diagonal elements of B. On exit, if info > 0,\nthe off-diagonal elements of a bidiagonal matrix\northogonally equivalent to B (if info = 0 this matrix converges to zero).\n@param[inout]\nV           pointer to type. Array on the GPU of dimension ldv*nv.\nOn entry, the matrix V. On exit, it is overwritten with P'*V.\n(Not referenced if nv = 0).\n@param[in]\nldv         rocblas_int. ldv >= n if nv > 0, or ldv >=1 if nv = 0.\nThe leading dimension of V.\n@param[inout]\nU           pointer to type. Array on the GPU of dimension ldu*n.\nOn entry, the matrix U. On exit, it is overwritten with U*Q.\n(Not referenced if nu = 0).\n@param[in]\nldu         rocblas_int. ldu >= nu.\nThe leading dimension of U.\n@param[inout]\nC           pointer to type. Array on the GPU of dimension ldc*nc.\nOn entry, the matrix C. On exit, it is overwritten with Q'*C.\n(Not referenced if nc = 0).\n@param[in]\nldc         rocblas_int. ldc >= n if nc > 0, or ldc >=1 if nc = 0.\nThe leading dimension of C.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, i elements of E have not converged to zero."]
    pub fn rocsolver_sbdsqr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nv: rocblas_int,
        nu: rocblas_int,
        nc: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        V: *mut f32,
        ldv: rocblas_int,
        U: *mut f32,
        ldu: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dbdsqr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nv: rocblas_int,
        nu: rocblas_int,
        nc: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        V: *mut f64,
        ldv: rocblas_int,
        U: *mut f64,
        ldu: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cbdsqr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nv: rocblas_int,
        nu: rocblas_int,
        nc: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zbdsqr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nv: rocblas_int,
        nu: rocblas_int,
        nc: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief STERF computes the eigenvalues of a symmetric tridiagonal matrix.\n\n\\details\nThe eigenvalues of the symmetric tridiagonal matrix are computed by the\nPal-Walker-Kahan variant of the QL/QR algorithm, and returned in\nincreasing order.\n\nThe matrix is not represented explicitly, but rather as the array of\ndiagonal elements D and the array of symmetric off-diagonal elements E.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the tridiagonal matrix.\n@param[inout]\nD           pointer to real type. Array on the GPU of dimension n.\nOn entry, the diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, the eigenvalues in increasing order.\nIf info > 0, the diagonal elements of a tridiagonal matrix\nthat is similar to the original matrix (i.e. has the same\neigenvalues).\n@param[inout]\nE           pointer to real type. Array on the GPU of dimension n-1.\nOn entry, the off-diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, this array converges to zero.\nIf info > 0, the off-diagonal elements of a tridiagonal matrix\nthat is similar to the original matrix (i.e. has the same\neigenvalues).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, STERF did not converge. i elements of E did not\nconverge to zero."]
    pub fn rocsolver_ssterf(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsterf(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief STEQR computes the eigenvalues and (optionally) eigenvectors of\na symmetric tridiagonal matrix.\n\n\\details\nThe eigenvalues of the symmetric tridiagonal matrix are computed by the\nimplicit QL/QR algorithm, and returned in increasing order.\n\nThe matrix is not represented explicitly, but rather as the array of\ndiagonal elements D and the array of symmetric off-diagonal elements E.\nWhen D and E correspond to the tridiagonal form of a full symmetric/Hermitian matrix, as returned by, e.g.,\n\\ref rocsolver_ssytrd \"SYTRD\" or \\ref rocsolver_chetrd \"HETRD\", the eigenvectors of the original matrix can also\nbe computed, depending on the value of evect.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies how the eigenvectors are computed.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the tridiagonal matrix.\n@param[inout]\nD           pointer to real type. Array on the GPU of dimension n.\nOn entry, the diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, the eigenvalues in increasing order.\nIf info > 0, the diagonal elements of a tridiagonal matrix\nthat is similar to the original matrix (i.e. has the same\neigenvalues).\n@param[inout]\nE           pointer to real type. Array on the GPU of dimension n-1.\nOn entry, the off-diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, this array converges to zero.\nIf info > 0, the off-diagonal elements of a tridiagonal matrix\nthat is similar to the original matrix (i.e. has the same\neigenvalues).\n@param[inout]\nC           pointer to type. Array on the GPU of dimension ldc*n.\nOn entry, if evect is original, the orthogonal/unitary matrix\nused for the reduction to tridiagonal form as returned by, e.g.,\n\\ref rocsolver_sorgtr \"ORGTR\" or \\ref rocsolver_cungtr \"UNGTR\".\nOn exit, it is overwritten with the eigenvectors of the original\nsymmetric/Hermitian matrix (if evect is original), or the\neigenvectors of the tridiagonal matrix (if evect is tridiagonal).\n(Not referenced if evect is none).\n@param[in]\nldc         rocblas_int. ldc >= n if evect is original or tridiagonal.\nSpecifies the leading dimension of C.\n(Not referenced if evect is none).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, STEQR did not converge. i elements of E did not\nconverge to zero."]
    pub fn rocsolver_ssteqr(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsteqr(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_csteqr(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zsteqr(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief STEDC computes the eigenvalues and (optionally) eigenvectors of\na symmetric tridiagonal matrix.\n\n\\details\nThis function uses the divide and conquer method to compute the eigenvectors.\nThe eigenvalues are returned in increasing order.\n\nThe matrix is not represented explicitly, but rather as the array of\ndiagonal elements D and the array of symmetric off-diagonal elements E.\nWhen D and E correspond to the tridiagonal form of a full symmetric/Hermitian matrix, as returned by, e.g.,\n\\ref rocsolver_ssytrd \"SYTRD\" or \\ref rocsolver_chetrd \"HETRD\", the eigenvectors of the original matrix can also\nbe computed, depending on the value of evect.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies how the eigenvectors are computed.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the tridiagonal matrix.\n@param[inout]\nD           pointer to real type. Array on the GPU of dimension n.\nOn entry, the diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, the eigenvalues in increasing order.\n@param[inout]\nE           pointer to real type. Array on the GPU of dimension n-1.\nOn entry, the off-diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, the values of this array are destroyed.\n@param[inout]\nC           pointer to type. Array on the GPU of dimension ldc*n.\nOn entry, if evect is original, the orthogonal/unitary matrix\nused for the reduction to tridiagonal form as returned by, e.g.,\n\\ref rocsolver_sorgtr \"ORGTR\" or \\ref rocsolver_cungtr \"UNGTR\".\nOn exit, if info = 0, it is overwritten with the eigenvectors of the original\nsymmetric/Hermitian matrix (if evect is original), or the\neigenvectors of the tridiagonal matrix (if evect is tridiagonal).\n(Not referenced if evect is none).\n@param[in]\nldc         rocblas_int. ldc >= n if evect is original or tridiagonal.\nSpecifies the leading dimension of C. (Not referenced if evect is none).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, STEDC failed to compute an eigenvalue on the sub-matrix formed by\nthe rows and columns info/(n+1) through mod(info,n+1)."]
    pub fn rocsolver_sstedc(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dstedc(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cstedc(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zstedc(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief STEBZ computes a set of eigenvalues of a symmetric tridiagonal matrix T.\n\n\\details\nThis function computes all the eigenvalues of T, all the eigenvalues in the half-open interval (vl, vu],\nor the il-th through iu-th eigenvalues, depending on the value of erange.\n\nThe eigenvalues are returned in increasing order either for the entire matrix, or grouped by independent\ndiagonal blocks (if they exist), depending on the value of eorder.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\neorder      #rocblas_eorder.\nSpecifies whether the computed eigenvalues will be ordered by their position in the\nentire spectrum, or grouped by independent diagonal (split off) blocks.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the tridiagonal matrix T.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if erange indicates to look\nfor all the eigenvalues of T or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if erange indicates to look\nfor all the eigenvalues of T or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if erange indicates to look\nfor all the eigenvalues of T or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest eigenvalue to be computed. Ignored if erange indicates to look\nfor all the eigenvalues of T or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[in]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of the tridiagonal matrix.\n@param[in]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of the tridiagonal matrix.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found.\n@param[out]\nnsplit      pointer to a rocblas_int on the GPU.\nThe number of split off blocks in the matrix.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\niblock      pointer to rocblas_int. Array on the GPU of dimension n.\nThe block indices corresponding to each eigenvalue. When matrix T has\nsplit off blocks (nsplit > 1), then if iblock[i] = k, the\neigenvalue W[i] belongs to the k-th diagonal block from the top.\n@param[out]\nisplit      pointer to rocblas_int. Array on the GPU of dimension n.\nThe splitting indices that divide the tridiagonal matrix into\ndiagonal blocks. The k-th block stretches from the end of the (k-1)-th\nblock (or the top left corner of the tridiagonal matrix,\nin the case of the 1st block) to the isplit[k]-th row/column.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = 1, the bisection did not converge for some eigenvalues, i.e. the returned\nvalues are not as accurate as the given tolerance. The non-converged eigenvalues\nare flagged by negative entries in iblock.\n"]
    pub fn rocsolver_sstebz(
        handle: rocblas_handle,
        erange: rocblas_erange,
        eorder: rocblas_eorder,
        n: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        D: *mut f32,
        E: *mut f32,
        nev: *mut rocblas_int,
        nsplit: *mut rocblas_int,
        W: *mut f32,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dstebz(
        handle: rocblas_handle,
        erange: rocblas_erange,
        eorder: rocblas_eorder,
        n: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        D: *mut f64,
        E: *mut f64,
        nev: *mut rocblas_int,
        nsplit: *mut rocblas_int,
        W: *mut f64,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief STEIN computes the eigenvectors associated with a set of\nprovided eigenvalues of a symmetric tridiagonal matrix.\n\n\\details\nThe eigenvectors of the symmetric tridiagonal matrix are computed using\ninverse iteration.\n\nThe matrix is not represented explicitly, but rather as the array of\ndiagonal elements D and the array of symmetric off-diagonal elements E.\nThe eigenvalues must be provided in the array W, as returned by \\ref rocsolver_sstebz \"STEBZ\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the tridiagonal matrix.\n@param[in]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of the tridiagonal matrix.\n@param[in]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of the tridiagonal matrix.\n@param[in]\nnev         pointer to a rocblas_int on the GPU. 0 <= nev <= n.\nThe number of provided eigenvalues, and the number of eigenvectors\nto be computed.\n@param[in]\nW           pointer to real type. Array on the GPU of dimension >= nev.\nA subset of nev eigenvalues of the tridiagonal matrix, as returned\nby \\ref rocsolver_sstebz \"STEBZ\".\n@param[in]\niblock      pointer to rocblas_int. Array on the GPU of dimension n.\nThe block indices corresponding to each eigenvalue, as\nreturned by \\ref rocsolver_sstebz \"STEBZ\". If iblock[i] = k,\nthen eigenvalue W[i] belongs to the k-th block from the top.\n@param[in]\nisplit      pointer to rocblas_int. Array on the GPU of dimension n.\nThe splitting indices that divide the tridiagonal matrix into\ndiagonal blocks, as returned by \\ref rocsolver_sstebz \"STEBZ\".\nThe k-th block stretches from the end of the (k-1)-th\nblock (or the top left corner of the tridiagonal matrix,\nin the case of the 1st block) to the isplit[k]-th row/column.\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, contains the eigenvectors of the tridiagonal matrix\ncorresponding to the provided eigenvalues, stored by columns.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, i eigenvectors did not converge; their indices are stored in\nIFAIL.\n"]
    pub fn rocsolver_sstein(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        Z: *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dstein(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        Z: *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cstein(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zstein(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief BDSVDX computes a set of singular values of a bidiagonal matrix B.\n\n\\details\nThis function computes all the singular values of B, all the singular values in the half-open interval\n\\f$[vl, vu)\\f$, or the il-th through iu-th singular values, depending on the value of srange.\n\nDepending on the value of svect, the corresponding singular vectors will be computed and stored as blocks\nin the output matrix Z. That is,\n\n\\f[\nZ = \\left[\\begin{array}{c}\nU\\\\\nV\n\\end{array}\\right]\n\\f]\n\nwhere U contains the corresponding left singular vectors of B, and V contains the corresponding right\nsingular vectors.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether B is upper or lower bidiagonal.\n@param[in]\nsvect       #rocblas_svect.\nSpecifies how the singular vectors are computed. Only rocblas_svect_none and\nrocblas_svect_singular are accepted.\n@param[in]\nsrange      #rocblas_srange.\nSpecifies the type of range or interval of the singular values to be computed.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the bidiagonal matrix B.\n@param[in]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of the bidiagonal matrix.\n@param[in]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of the bidiagonal matrix.\n@param[in]\nvl          real type. 0 <= vl < vu.\nThe lower bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of B or the singular values within a set of indices.\n@param[in]\nvu          real type. 0 <= vl < vu.\nThe upper bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of B or the singular values within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of B or the singular values in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of B or the singular values in a half-open interval.\n@param[out]\nnsv         pointer to a rocblas_int on the GPU.\nThe total number of singular values found. If srange is rocblas_srange_all, nsv = n.\nIf srange is rocblas_srange_index, nsv = iu - il + 1. Otherwise, 0 <= nsv <= n.\n@param[out]\nS           pointer to real type. Array on the GPU of dimension nsv.\nThe first nsv elements contain the computed singular values in descending order.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that S is large enough to hold n values.\n@param[out]\nZ           pointer to real type. Array on the GPU of dimension ldz*nsv.\nIf info = 0, the first nsv columns contain the computed singular vectors corresponding to the\nsingular values in S. The first n rows of Z contain the matrix U, and the next n rows contain\nthe matrix V. Not referenced if svect is rocblas_svect_none.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that Z is large enough to hold n columns.\n@param[in]\nldz         rocblas_int. ldz >= 2*n if svect is rocblas_svect_singular; ldz >= 1 otherwise.\nSpecifies the leading dimension of Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nsv elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge, as returned by \\ref rocsolver_sstein \"STEIN\".\nNot referenced if svect is rocblas_svect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, i eigenvectors did not converge in \\ref rocsolver_sstein \"STEIN\"; their\nindices are stored in ifail.\n"]
    pub fn rocsolver_sbdsvdx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        svect: rocblas_svect,
        srange: rocblas_srange,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        Z: *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dbdsvdx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        svect: rocblas_svect,
        srange: rocblas_srange,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        Z: *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETF2_NPVT computes the LU factorization of a general m-by-n matrix A\nwithout partial pivoting.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization has the form\n\n\\f[\nA = LU\n\\f]\n\nwhere L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\n\n\\note\nAlthough this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK API \\ref rocsolver_sgetf2 \"GETF2\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete."]
    pub fn rocsolver_sgetf2_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetf2_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetf2_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetf2_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETF2_NPVT_BATCHED computes the LU factorization of a batch of\ngeneral m-by-n matrices without partial pivoting.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = L_lU_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n\\note\nAlthough this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK API \\ref rocsolver_sgetf2_batched \"GETF2_BATCHED\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[in,out]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorizations.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetf2_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetf2_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetf2_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetf2_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETF2_NPVT_STRIDED_BATCHED computes the LU factorization of a batch\nof general m-by-n matrices without partial pivoting.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = L_lU_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n\\note\nAlthough this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK-like API \\ref rocsolver_sgetf2_strided_batched \"GETF2_STRIDED_BATCHED\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorization.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetf2_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetf2_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetf2_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetf2_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRF_NPVT computes the LU factorization of a general m-by-n matrix A\nwithout partial pivoting.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization has the form\n\n\\f[\nA = LU\n\\f]\n\nwhere L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\n\nNote: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK-like API \\ref rocsolver_sgetrf \"GETRF\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete."]
    pub fn rocsolver_sgetrf_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrf_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrf_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrf_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRF_NPVT_BATCHED computes the LU factorization of a batch of\ngeneral m-by-n matrices without partial pivoting.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = L_lU_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\nNote: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK-like API \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorizations.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch.\n"]
    pub fn rocsolver_sgetrf_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrf_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrf_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrf_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRF_NPVT_STRIDED_BATCHED computes the LU factorization of a batch\nof general m-by-n matrices without partial pivoting.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = L_lU_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\nNote: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK-like API \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorization.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch.\n"]
    pub fn rocsolver_sgetrf_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrf_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrf_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrf_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETF2 computes the LU factorization of a general m-by-n matrix A\nusing partial pivoting with row interchanges.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization has the form\n\n\\f[\nA = PLU\n\\f]\n\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension min(m,n).\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= i <= min(m,n), the row i of the\nmatrix was interchanged with row ipiv[i].\nMatrix P of the factorization can be derived from ipiv.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetf2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetf2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetf2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetf2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETF2_BATCHED computes the LU factorization of a batch of general\nm-by-n matrices using partial pivoting with row interchanges.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = P_lL_lU_l\n\\f]\n\nwhere \\f$P_l\\f$ is a permutation matrix, \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorizations.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors of pivot indices ipiv_l (corresponding to A_l).\nDimension of ipiv_l is min(m,n).\nElements of ipiv_l are 1-based indices.\nFor each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the\nmatrix A_l was interchanged with row ipiv_l[i].\nMatrix P_l of the factorization can be derived from ipiv_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetf2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetf2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetf2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetf2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETF2_STRIDED_BATCHED computes the LU factorization of a batch of\ngeneral m-by-n matrices using partial pivoting with row interchanges.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = P_lL_lU_l\n\\f]\n\nwhere \\f$P_l\\f$ is a permutation matrix, \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorization.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors of pivots indices ipiv_l (corresponding to A_l).\nDimension of ipiv_l is min(m,n).\nElements of ipiv_l are 1-based indices.\nFor each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the\nmatrix A_l was interchanged with row ipiv_l[i].\nMatrix P_l of the factorization can be derived from ipiv_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetf2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetf2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetf2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetf2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRF computes the LU factorization of a general m-by-n matrix A\nusing partial pivoting with row interchanges.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization has the form\n\n\\f[\nA = PLU\n\\f]\n\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension min(m,n).\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= i <= min(m,n), the row i of the\nmatrix was interchanged with row ipiv[i].\nMatrix P of the factorization can be derived from ipiv.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRF_BATCHED computes the LU factorization of a batch of general\nm-by-n matrices using partial pivoting with row interchanges.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = P_lL_lU_l\n\\f]\n\nwhere \\f$P_l\\f$ is a permutation matrix, \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorizations.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors of pivot indices ipiv_l (corresponding to A_l).\nDimension of ipiv_l is min(m,n).\nElements of ipiv_l are 1-based indices.\nFor each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the\nmatrix A_l was interchanged with row ipiv_l[i].\nMatrix P_l of the factorization can be derived from ipiv_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRF_STRIDED_BATCHED computes the LU factorization of a batch of\ngeneral m-by-n matrices using partial pivoting with row interchanges.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = P_lL_lU_l\n\\f]\n\nwhere \\f$P_l\\f$ is a permutation matrix, \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorization.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors of pivots indices ipiv_l (corresponding to A_l).\nDimension of ipiv_l is min(m,n).\nElements of ipiv_l are 1-based indices.\nFor each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the\nmatrix A_l was interchanged with row ipiv_l[i].\nMatrix P_l of the factorization can be derived from ipiv_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQR2 computes a QR factorization of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\nR\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(1)H(2)\\cdots H(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R; the elements below the diagonal are the last m - i elements\nof Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgeqr2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqr2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqr2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqr2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQR2_BATCHED computes the QR factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\nR_l\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)H_l(2)\\cdots H_l(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_l. The elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqr2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqr2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqr2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqr2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQR2_STRIDED_BATCHED computes the QR factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\nR_l\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)H_l(2)\\cdots H_l(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_l. The elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqr2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqr2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqr2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqr2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GERQ2 computes a RQ factorization of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = \\left[\\begin{array}{cc}\n0 & R\n\\end{array}\\right] Q\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m > n), and Q is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(1)'H(2)' \\cdots H(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgerq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgerq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgerq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgerq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GERQ2_BATCHED computes the RQ factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\n0 & R_l\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)'H_l(2)' \\cdots H_l(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last n-i elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R_l; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgerq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgerq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgerq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgerq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GERQ2_STRIDED_BATCHED computes the RQ factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\n0 & R_l\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)'H_l(2)' \\cdots H_l(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last n-i elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R_l; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgerq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgerq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgerq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgerq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQL2 computes a QL factorization of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\n0\\\\\nL\n\\end{array}\\right]\n\\f]\n\nwhere L is lower triangular (lower trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgeql2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeql2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeql2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeql2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQL2_BATCHED computes the QL factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\n0\\\\\nL_l\n\\end{array}\\right]\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)H_l(k-1)\\cdots H_l(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L_l; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeql2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeql2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeql2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeql2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQL2_STRIDED_BATCHED computes the QL factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\n0\\\\\nL_l\n\\end{array}\\right]\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)H_l(k-1)\\cdots H_l(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L_l; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeql2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeql2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeql2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeql2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELQ2 computes a LQ factorization of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = \\left[\\begin{array}{cc}\nL & 0\n\\end{array}\\right] Q\n\\f]\n\nwhere L is lower triangular (lower trapezoidal if m > n), and Q is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(k)'H(k-1)' \\cdots H(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i' v_i^{}\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L; the elements above the diagonal are the last n - i elements\nof Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgelq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgelq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgelq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgelq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELQ2_BATCHED computes the LQ factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\nL_l & 0\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)'H_l(k-1)' \\cdots H_l(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}' v_{l_i}^{}\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L_l. The elements above the diagonal are the last n - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgelq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgelq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgelq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgelq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELQ2_STRIDED_BATCHED computes the LQ factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\nL_l & 0\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)'H_l(k-1)' \\cdots H_l(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}' v_{l_i}^{}\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle    rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L_l. The elements above the diagonal are the last n - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgelq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgelq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgelq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgelq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQRF computes a QR factorization of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\nR\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(1)H(2)\\cdots H(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R; the elements below the diagonal are the last m - i elements\nof Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgeqrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQRF_BATCHED computes the QR factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\nR_l\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)H_l(2)\\cdots H_l(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_l. The elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQRF_STRIDED_BATCHED computes the QR factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\nR_l\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)H_l(2)\\cdots H_l(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_l. The elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GERQF computes a RQ factorization of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = \\left[\\begin{array}{cc}\n0 & R\n\\end{array}\\right] Q\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m > n), and Q is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(1)'H(2)' \\cdots H(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgerqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgerqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgerqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgerqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GERQF_BATCHED computes the RQ factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\n0 & R_l\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)'H_l(2)' \\cdots H_l(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last n-i elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R_l; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgerqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgerqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgerqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgerqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GERQF_STRIDED_BATCHED computes the RQ factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\n0 & R_l\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)'H_l(2)' \\cdots H_l(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last n-i elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R_l; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgerqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgerqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgerqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgerqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQLF computes a QL factorization of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\n0\\\\\nL\n\\end{array}\\right]\n\\f]\n\nwhere L is lower triangular (lower trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgeqlf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqlf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqlf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqlf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQLF_BATCHED computes the QL factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\n0\\\\\nL_l\n\\end{array}\\right]\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)H_l(k-1)\\cdots H_l(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L_l; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqlf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqlf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqlf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqlf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEQLF_STRIDED_BATCHED computes the QL factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\n0\\\\\nL_l\n\\end{array}\\right]\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)H_l(k-1)\\cdots H_l(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L_l; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqlf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeqlf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeqlf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeqlf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELQF computes a LQ factorization of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = \\left[\\begin{array}{cc}\nL & 0\n\\end{array}\\right] Q\n\\f]\n\nwhere L is lower triangular (lower trapezoidal if m > n), and Q is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(k)'H(k-1)' \\cdots H(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i' v_i^{}\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L; the elements above the diagonal are the last n - i elements\nof Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgelqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgelqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgelqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgelqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELQF_BATCHED computes the LQ factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\nL_l & 0\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)'H_l(k-1)' \\cdots H_l(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}' v_{l_i}^{}\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L_l. The elements above the diagonal are the last n - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgelqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgelqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgelqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgelqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELQF_STRIDED_BATCHED computes the LQ factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\nL_l & 0\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)'H_l(k-1)' \\cdots H_l(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}' v_{l_i}^{}\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L_l. The elements above the diagonal are the last n - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgelqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgelqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgelqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgelqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBD2 computes the bidiagonal form of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe bidiagonal form is given by:\n\n\\f[\nB = Q'  A  P\n\\f]\n\nwhere B is upper bidiagonal if m >= n and lower bidiagonal if m < n, and Q and\nP are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n)\\:  \\text{and} \\: P = G(1)G(2)\\cdots G(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ = H(1)H(2)\\cdots H(m-1)\\:  \\text{and} \\: P = G(1)G(2)\\cdots G(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ and \\f$G(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH(i) = I - \\text{tauq}[i] \\cdot v_i^{} v_i', & \\: \\text{and}\\\\\nG(i) = I - \\text{taup}[i] \\cdot u_i' u_i^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_i, and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_i.\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_i, and the elements above the\ndiagonal are the last n - i elements of Householder vector u_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nspecifies the leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension min(m,n).\nThe diagonal elements of B.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension min(m,n)-1.\nThe off-diagonal elements of B.\n@param[out]\ntauq        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars associated with matrix Q.\n@param[out]\ntaup        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars associated with matrix P."]
    pub fn rocsolver_sgebd2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgebd2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgebd2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut rocblas_float_complex,
        taup: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgebd2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut rocblas_double_complex,
        taup: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBD2_BATCHED computes the bidiagonal form of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the bidiagonal form is given by:\n\n\\f[\nB_l^{} = Q_l'  A_l^{}  P_l^{}\n\\f]\n\nwhere \\f$B_l\\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \\f$Q_l\\f$ and\n\\f$P_l\\f$ are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ_l = H_l(1)H_l(2)\\cdots H_l(m-1)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ and \\f$G_l(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH_l^{}(i) = I - \\text{tauq}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}', & \\: \\text{and}\\\\\nG_l^{}(i) = I - \\text{taup}_l^{}[i] \\cdot u_{l_i}' u_{l_i}^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B_l.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i), and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_(l_i), and the elements above the\ndiagonal are the last n - i elements of Householder vector u_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of B_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of B_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[out]\ntauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).\nContains the vectors tauq_l of Householder scalars associated with matrices Q_l.\n@param[in]\nstrideQ     rocblas_stride.\nStride from the start of one vector tauq_l to the next one tauq_(l+1).\nThere is no restriction for the value\nof strideQ. Normal use is strideQ >= min(m,n).\n@param[out]\ntaup        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors taup_l of Householder scalars associated with matrices P_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector taup_l to the next one taup_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgebd2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut f32,
        strideQ: rocblas_stride,
        taup: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgebd2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut f64,
        strideQ: rocblas_stride,
        taup: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgebd2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut rocblas_float_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgebd2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut rocblas_double_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBD2_STRIDED_BATCHED computes the bidiagonal form of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the bidiagonal form is given by:\n\n\\f[\nB_l^{} = Q_l'  A_l^{}  P_l^{}\n\\f]\n\nwhere \\f$B_l\\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \\f$Q_l\\f$ and\n\\f$P_l\\f$ are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n)\\:  \\text{and} \\: P_1 = G_l(1)G_l(2)\\cdots G_l(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ_l = H_l(1)H_l(2)\\cdots H_l(m-1)\\:  \\text{and} \\: P_1 = G_l(1)G_l(2)\\cdots G_l(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ and \\f$G_l(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH_l^{}(i) = I - \\text{tauq}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}', & \\: \\text{and}\\\\\nG_l^{}(i) = I - \\text{taup}_l^{}[i] \\cdot u_{l_i}' u_{l_i}^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B_l.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i), and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_(l_i), and the elements above the\ndiagonal are the last n - i elements of Householder vector u_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of B_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of B_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[out]\ntauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).\nContains the vectors tauq_l of Householder scalars associated with matrices Q_l.\n@param[in]\nstrideQ     rocblas_stride.\nStride from the start of one vector tauq_l to the next one tauq_(l+1).\nThere is no restriction for the value\nof strideQ. Normal use is strideQ >= min(m,n).\n@param[out]\ntaup        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors taup_l of Householder scalars associated with matrices P_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector taup_l to the next one taup_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgebd2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut f32,
        strideQ: rocblas_stride,
        taup: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgebd2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut f64,
        strideQ: rocblas_stride,
        taup: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgebd2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut rocblas_float_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgebd2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut rocblas_double_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBRD computes the bidiagonal form of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe bidiagonal form is given by:\n\n\\f[\nB = Q'  A  P\n\\f]\n\nwhere B is upper bidiagonal if m >= n and lower bidiagonal if m < n, and Q and\nP are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n)\\:  \\text{and} \\: P = G(1)G(2)\\cdots G(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ = H(1)H(2)\\cdots H(m-1)\\:  \\text{and} \\: P = G(1)G(2)\\cdots G(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ and \\f$G(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH(i) = I - \\text{tauq}[i] \\cdot v_i^{} v_i', & \\: \\text{and}\\\\\nG(i) = I - \\text{taup}[i] \\cdot u_i' u_i^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_i, and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_i.\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_i, and the elements above the\ndiagonal are the last n - i elements of Householder vector u_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nspecifies the leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension min(m,n).\nThe diagonal elements of B.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension min(m,n)-1.\nThe off-diagonal elements of B.\n@param[out]\ntauq        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars associated with matrix Q.\n@param[out]\ntaup        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars associated with matrix P."]
    pub fn rocsolver_sgebrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgebrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgebrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut rocblas_float_complex,
        taup: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgebrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut rocblas_double_complex,
        taup: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBRD_BATCHED computes the bidiagonal form of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the bidiagonal form is given by:\n\n\\f[\nB_l^{} = Q_l'  A_l^{}  P_l^{}\n\\f]\n\nwhere \\f$B_l\\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \\f$Q_l\\f$ and\n\\f$P_l\\f$ are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ_l = H_l(1)H_l(2)\\cdots H_l(m-1)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ and \\f$G_l(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH_l^{}(i) = I - \\text{tauq}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}', & \\: \\text{and}\\\\\nG_l^{}(i) = I - \\text{taup}_l^{}[i] \\cdot u_{l_i}' u_{l_i}^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B_l.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i), and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_(l_i), and the elements above the\ndiagonal are the last n - i elements of Householder vector u_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of B_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of B_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[out]\ntauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).\nContains the vectors tauq_l of Householder scalars associated with matrices Q_l.\n@param[in]\nstrideQ     rocblas_stride.\nStride from the start of one vector tauq_l to the next one tauq_(l+1).\nThere is no restriction for the value\nof strideQ. Normal use is strideQ >= min(m,n).\n@param[out]\ntaup        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors taup_l of Householder scalars associated with matrices P_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector taup_l to the next one taup_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgebrd_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut f32,
        strideQ: rocblas_stride,
        taup: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgebrd_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut f64,
        strideQ: rocblas_stride,
        taup: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgebrd_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut rocblas_float_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgebrd_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut rocblas_double_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBRD_STRIDED_BATCHED computes the bidiagonal form of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the bidiagonal form is given by:\n\n\\f[\nB_l^{} = Q_l'  A_l^{}  P_l^{}\n\\f]\n\nwhere \\f$B_l\\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \\f$Q_l\\f$ and\n\\f$P_l\\f$ are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ_l = H_l(1)H_l(2)\\cdots H_l(m-1)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ and \\f$G_l(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH_l^{}(i) = I - \\text{tauq}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}', & \\: \\text{and}\\\\\nG_l^{}(i) = I - \\text{taup}_l^{}[i] \\cdot u_{l_i}' u_{l_i}^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B_l.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i), and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_(l_i), and the elements above the\ndiagonal are the last n - i elements of Householder vector u_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of B_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of B_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[out]\ntauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).\nContains the vectors tauq_l of Householder scalars associated with matrices Q_l.\n@param[in]\nstrideQ     rocblas_stride.\nStride from the start of one vector tauq_l to the next one tauq_(l+1).\nThere is no restriction for the value\nof strideQ. Normal use is strideQ >= min(m,n).\n@param[out]\ntaup        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors taup_l of Householder scalars associated with matrices P_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector taup_l to the next one taup_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgebrd_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut f32,
        strideQ: rocblas_stride,
        taup: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgebrd_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut f64,
        strideQ: rocblas_stride,
        taup: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgebrd_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut rocblas_float_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgebrd_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut rocblas_double_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRS solves a system of n linear equations on n variables in its factorized form.\n\n\\details\nIt solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA X = B & \\: \\text{not transposed,}\\\\\nA^T X = B & \\: \\text{transposed, or}\\\\\nA^H X = B & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix A is defined by its triangular factors as returned by \\ref rocsolver_sgetrf \"GETRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\nThe factors L and U of the factorization A = P*L*U returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe pivot indices returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B."]
    pub fn rocsolver_sgetrs(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrs(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrs(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrs(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRS_BATCHED solves a batch of systems of n linear equations on n\nvariables in its factorized forms.\n\n\\details\nFor each instance l in the batch, it solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = B_l & \\: \\text{not transposed,}\\\\\nA_l^T X_l^{} = B_l^{} & \\: \\text{transposed, or}\\\\\nA_l^H X_l^{} = B_l^{} & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix \\f$A_l\\f$ is defined by its triangular factors as returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations of each instance in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nThe factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of pivot indices returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[inout]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sgetrs_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrs_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrs_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrs_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRS_STRIDED_BATCHED solves a batch of systems of n linear equations\non n variables in its factorized forms.\n\n\\details\nFor each instance l in the batch, it solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = B_l & \\: \\text{not transposed,}\\\\\nA_l^T X_l^{} = B_l^{} & \\: \\text{transposed, or}\\\\\nA_l^H X_l^{} = B_l^{} & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix \\f$A_l\\f$ is defined by its triangular factors as returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations of each instance in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nThe factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of pivot indices returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[inout]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sgetrs_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetrs_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetrs_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetrs_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESV solves a general system of n linear equations on n variables.\n\n\\details\nThe linear system is of the form\n\n\\f[\nA X = B\n\\f]\n\nwhere A is a general n-by-n matrix. Matrix A is first factorized in triangular factors L and U\nusing \\ref rocsolver_sgetrf \"GETRF\"; then, the solution is computed with \\ref rocsolver_sgetrs \"GETRS\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, if info = 0, the factors L and U of the LU decomposition of A returned by\n\\ref rocsolver_sgetrf \"GETRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe pivot indices returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular, and the solution could not be computed.\nU[i,i] is the first zero element in the diagonal."]
    pub fn rocsolver_sgesv(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesv(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesv(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesv(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESV_BATCHED solves a batch of general systems of n linear equations on n\nvariables.\n\n\\details\nThe linear systems are of the form\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a general n-by-n matrix. Matrix \\f$A_l\\f$ is first factorized in triangular factors \\f$L_l\\f$ and \\f$U_l\\f$\nusing \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\"; then, the solutions are computed with \\ref rocsolver_sgetrs_batched \"GETRS_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, if info[l] = 0, the factors L_l and U_l of the LU decomposition of A_l returned by\n\\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe vectors ipiv_l of pivot indices returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[inout]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for A_l.\nIf info[l] = i > 0, U_l is singular, and the solution could not be computed.\nU_l[i,i] is the first zero element in the diagonal.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sgesv_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesv_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesv_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesv_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESV_STRIDED_BATCHED solves a batch of general systems of n linear equations\non n variables.\n\n\\details\nThe linear systems are of the form\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a general n-by-n matrix. Matrix \\f$A_l\\f$ is first factorized in triangular factors \\f$L_l\\f$ and \\f$U_l\\f$\nusing \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\"; then, the solutions are computed with\n\\ref rocsolver_sgetrs_strided_batched \"GETRS_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l.\nOn exit, if info[l] = 0, the factors L_l and U_l of the LU decomposition of A_l returned by\n\\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[inout]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe vectors ipiv_l of pivot indices returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[inout]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for A_l.\nIf info[l] = i > 0, U_l is singular, and the solution could not be computed.\nU_l[i,i] is the first zero element in the diagonal.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sgesv_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesv_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesv_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesv_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI inverts a general n-by-n matrix A using the LU factorization\ncomputed by \\ref rocsolver_sgetrf \"GETRF\".\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA^{-1}L = U^{-1}\n\\f]\n\nwhere L is the lower triangular factor of A with unit diagonal elements, and U is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the factors L and U of the factorization A = P*L*U returned by \\ref rocsolver_sgetrf \"GETRF\".\nOn exit, the inverse of A if info = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe pivot indices returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetri(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_BATCHED inverts a batch of general n-by-n matrices using\nthe LU factorization computed by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed by solving the linear system\n\n\\f[\nA_l^{-1} L_l^{} = U_l^{-1}\n\\f]\n\nwhere \\f$L_l\\f$ is the lower triangular factor of \\f$A_l\\f$ with unit diagonal elements, and \\f$U_l\\f$ is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by\n\\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe pivot indices returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+j).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_STRIDED_BATCHED inverts a batch of general n-by-n matrices\nusing the LU factorization computed by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed by solving the linear system\n\n\\f[\nA_l^{-1} L_l^{} = U_l^{-1}\n\\f]\n\nwhere \\f$L_l\\f$ is the lower triangular factor of \\f$A_l\\f$ with unit diagonal elements, and \\f$U_l\\f$ is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by\n\\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe pivot indices returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_NPVT inverts a general n-by-n matrix A using the LU factorization\ncomputed by \\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\".\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA^{-1}L = U^{-1}\n\\f]\n\nwhere L is the lower triangular factor of A with unit diagonal elements, and U is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the factors L and U of the factorization A = L*U returned by \\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\".\nOn exit, the inverse of A if info = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetri_npvt(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_npvt(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_npvt(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_npvt(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_NPVT_BATCHED inverts a batch of general n-by-n matrices using\nthe LU factorization computed by \\ref rocsolver_sgetrf_npvt_batched \"GETRF_NPVT_BATCHED\".\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed by solving the linear system\n\n\\f[\nA_l^{-1} L_l^{} = U_l^{-1}\n\\f]\n\nwhere \\f$L_l\\f$ is the lower triangular factor of \\f$A_l\\f$ with unit diagonal elements, and \\f$U_l\\f$ is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the factors L_l and U_l of the factorization A_l = L_l*U_l returned by\n\\ref rocsolver_sgetrf_npvt_batched \"GETRF_NPVT_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_npvt_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_npvt_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_npvt_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_npvt_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_NPVT_STRIDED_BATCHED inverts a batch of general n-by-n matrices\nusing the LU factorization computed by \\ref rocsolver_sgetrf_npvt_strided_batched \"GETRF_NPVT_STRIDED_BATCHED\".\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed by solving the linear system\n\n\\f[\nA_l^{-1} L_l^{} = U_l^{-1}\n\\f]\n\nwhere \\f$L_l\\f$ is the lower triangular factor of \\f$A_l\\f$ with unit diagonal elements, and \\f$U_l\\f$ is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the factors L_l and U_l of the factorization A_l = L_l*U_l returned by\n\\ref rocsolver_sgetrf_npvt_strided_batched \"GETRF_NPVT_STRIDED_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_npvt_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_npvt_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_npvt_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_npvt_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELS solves an overdetermined (or underdetermined) linear system defined by an m-by-n\nmatrix A, and a corresponding matrix B, using the QR factorization computed by \\ref rocsolver_sgeqrf \"GEQRF\" (or the LQ\nfactorization computed by \\ref rocsolver_sgelqf \"GELQF\").\n\n\\details\nDepending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = B & \\: \\text{not transposed, or}\\\\\nA' X = B & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X is found by minimizing\n\n\\f[\n|| B - A  X || \\quad \\text{(or} \\: || B - A' X ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X is chosen such that \\f$|| X ||\\f$ is minimal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of columns of matrices B and X;\ni.e., the columns on the right hand side.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, the QR (or LQ) factorization of A as returned by \\ref rocsolver_sgeqrf \"GEQRF\" (or \\ref rocsolver_sgelqf \"GELQF\").\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrix A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the matrix B.\nOn exit, when info = 0, B is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         rocblas_int. ldb >= max(m,n).\nSpecifies the leading dimension of matrix B.\n@param[out]\ninfo        pointer to rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the solution could not be computed because input matrix A is\nrank deficient; the i-th diagonal element of its triangular factor is zero."]
    pub fn rocsolver_sgels(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgels(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgels(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgels(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELS_BATCHED solves a batch of overdetermined (or underdetermined) linear systems\ndefined by a set of m-by-n matrices \\f$A_l\\f$, and corresponding matrices \\f$B_l\\f$, using the\nQR factorizations computed by \\ref rocsolver_sgeqrf_batched \"GEQRF_BATCHED\" (or the LQ factorizations computed by \\ref rocsolver_sgelqf_batched \"GELQF_BATCHED\").\n\n\\details\nFor each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = B_l & \\: \\text{not transposed, or}\\\\\nA_l' X_l^{} = B_l^{} & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X_l is found by minimizing\n\n\\f[\n|| B_l - A_l  X_l || \\quad \\text{(or} \\: || B_l^{} - A_l' X_l^{} ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X_l is chosen such that \\f$|| X_l ||\\f$ is minimal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of columns of all matrices B_l and X_l in the batch;\ni.e., the columns on the right hand side.\n@param[inout]\nA           array of pointer to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, the QR (or LQ) factorizations of A_l as returned by \\ref rocsolver_sgeqrf_batched \"GEQRF_BATCHED\"\n(or \\ref rocsolver_sgelqf_batched \"GELQF_BATCHED\").\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[inout]\nB           array of pointer to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the matrices B_l.\nOn exit, when info[l] = 0, B_l is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         rocblas_int. ldb >= max(m,n).\nSpecifies the leading dimension of matrices B_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for solution of A_l.\nIf info[l] = i > 0, the solution of A_l could not be computed because input\nmatrix A_l is rank deficient; the i-th diagonal element of its triangular factor is zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgels_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgels_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgels_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgels_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GELS_STRIDED_BATCHED solves a batch of overdetermined (or underdetermined) linear\nsystems defined by a set of m-by-n matrices \\f$A_l\\f$, and corresponding matrices \\f$B_l\\f$,\nusing the QR factorizations computed by \\ref rocsolver_sgeqrf_strided_batched \"GEQRF_STRIDED_BATCHED\"\n(or the LQ factorizations computed by \\ref rocsolver_sgelqf_strided_batched \"GELQF_STRIDED_BATCHED\").\n\n\\details\nFor each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = B_l & \\: \\text{not transposed, or}\\\\\nA_l' X_l^{} = B_l^{} & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X_l is found by minimizing\n\n\\f[\n|| B_l - A_l  X_l || \\quad \\text{(or} \\: || B_l^{} - A_l' X_l^{} ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X_l is chosen such that \\f$|| X_l ||\\f$ is minimal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of columns of all matrices B_l and X_l in the batch;\ni.e., the columns on the right hand side.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l.\nOn exit, the QR (or LQ) factorizations of A_l as returned by \\ref rocsolver_sgeqrf_strided_batched \"GEQRF_STRIDED_BATCHED\"\n(or \\ref rocsolver_sgelqf_strided_batched \"GELQF_STRIDED_BATCHED\").\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the matrices B_l.\nOn exit, when info[l] = 0, each B_l is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         rocblas_int. ldb >= max(m,n).\nSpecifies the leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for solution of A_l.\nIf info[l] = i > 0, the solution of A_l could not be computed because input\nmatrix A_l is rank deficient; the i-th diagonal element of its triangular factor is zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgels_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgels_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgels_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgels_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTF2 computes the Cholesky factorization of a real symmetric (complex\nHermitian) positive definite matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form:\n\n\\f[\n\\begin{array}{cl}\nA = U'U & \\: \\text{if uplo is upper, or}\\\\\nA = LL' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nU is an upper triangular matrix and L is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A to be factored. On exit, the lower or upper triangular factor.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful factorization of matrix A.\nIf info = i > 0, the leading minor of order i of A is not positive definite.\nThe factorization stopped at this point."]
    pub fn rocsolver_spotf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTF2_BATCHED computes the Cholesky factorization of a\nbatch of real symmetric (complex Hermitian) positive definite matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form:\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\n\\f$U_l\\f$ is an upper triangular matrix and \\f$L_l\\f$ is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful factorization of matrix A_l.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th factorization stopped at this point.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTF2_STRIDED_BATCHED computes the Cholesky factorization of a\nbatch of real symmetric (complex Hermitian) positive definite matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form:\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\n\\f$U_l\\f$ is an upper triangular matrix and \\f$L_l\\f$ is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA    rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful factorization of matrix A_l.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th factorization stopped at this point.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRF computes the Cholesky factorization of a real symmetric (complex\nHermitian) positive definite matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form:\n\n\\f[\n\\begin{array}{cl}\nA = U'U & \\: \\text{if uplo is upper, or}\\\\\nA = LL' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nU is an upper triangular matrix and L is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A to be factored. On exit, the lower or upper triangular factor.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful factorization of matrix A.\nIf info = i > 0, the leading minor of order i of A is not positive definite.\nThe factorization stopped at this point."]
    pub fn rocsolver_spotrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRF_BATCHED computes the Cholesky factorization of a\nbatch of real symmetric (complex Hermitian) positive definite matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form:\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\n\\f$U_l\\f$ is an upper triangular matrix and \\f$L_l\\f$ is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful factorization of matrix A_l.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th factorization stopped at this point.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRF_STRIDED_BATCHED computes the Cholesky factorization of a\nbatch of real symmetric (complex Hermitian) positive definite matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form:\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\n\\f$U_l\\f$ is an upper triangular matrix and \\f$L_l\\f$ is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful factorization of matrix A_l.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th factorization stopped at this point.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRS solves a symmetric/hermitian system of n linear equations on n variables in its factorized form.\n\n\\details\nIt solves the system\n\n\\f[\nA X = B\n\\f]\n\nwhere A is a real symmetric (complex hermitian) positive definite matrix defined by its triangular factor\n\n\\f[\n\\begin{array}{cl}\nA = U'U & \\: \\text{if uplo is upper, or}\\\\\nA = LL' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nas returned by \\ref rocsolver_spotrf \"POTRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\nThe factor L or U of the Cholesky factorization of A returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B."]
    pub fn rocsolver_spotrs(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotrs(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotrs(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotrs(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRS_BATCHED solves a batch of symmetric/hermitian systems of n linear equations on n\nvariables in its factorized forms.\n\n\\details\nFor each instance l in the batch, it solves the system\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a real symmetric (complex hermitian) positive definite matrix defined by its\ntriangular factor\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nas returned by \\ref rocsolver_spotrf \"POTRF_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nThe factor L_l or U_l of the Cholesky factorization of A_l returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[inout]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_spotrs_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotrs_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotrs_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotrs_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRS_STRIDED_BATCHED solves a batch of symmetric/hermitian systems of n linear equations\non n variables in its factorized forms.\n\n\\details\nFor each instance l in the batch, it solves the system\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a real symmetric (complex hermitian) positive definite matrix defined by its\ntriangular factor\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nas returned by \\ref rocsolver_spotrf \"POTRF_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nThe factor L_l or U_l of the Cholesky factorization of A_l returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[inout]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_spotrs_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotrs_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotrs_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotrs_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POSV solves a symmetric/hermitian system of n linear equations on n variables.\n\n\\details\nIt solves the system\n\n\\f[\nA X = B\n\\f]\n\nwhere A is a real symmetric (complex hermitian) positive definite matrix. Matrix A is first\nfactorized as \\f$A=LL'\\f$ or \\f$A=U'U\\f$, depending on the value of uplo, using \\ref rocsolver_spotrf \"POTRF\";\nthen, the solution is computed with \\ref rocsolver_spotrs \"POTRS\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric/hermitian matrix A.\nOn exit, if info = 0, the factor L or U of the Cholesky factorization of A returned by\n\\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the leading minor of order i of A is not positive definite.\nThe solution could not be computed."]
    pub fn rocsolver_sposv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dposv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cposv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zposv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POSV_BATCHED solves a batch of symmetric/hermitian systems of n linear equations on n\nvariables.\n\n\\details\nFor each instance l in the batch, it solves the system\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a real symmetric (complex hermitian) positive definite matrix. Matrix \\f$A_l\\f$ is first\nfactorized as \\f$A_l^{}=L_l^{}L_l'\\f$ or \\f$A_l^{}=U_l'U_l^{}\\f$, depending on the value of uplo, using \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\";\nthen, the solution is computed with \\ref rocsolver_spotrs_batched \"POTRS_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric/hermitian matrices A_l.\nOn exit, if info[l] = 0, the factor L_l or U_l of the Cholesky factorization of A_l returned by\n\\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[inout]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th solution could not be computed.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sposv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dposv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cposv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zposv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POSV_STRIDED_BATCHED solves a batch of symmetric/hermitian systems of n linear equations\non n variables.\n\n\\details\nFor each instance l in the batch, it solves the system\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a real symmetric (complex hermitian) positive definite matrix. Matrix \\f$A_l\\f$ is first\nfactorized as \\f$A_l^{}=L_l^{}L_l'\\f$ or \\f$A_l^{}=U_l'U_l^{}\\f$, depending on the value of uplo, using \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\";\nthen, the solution is computed with \\ref rocsolver_spotrs_strided_batched \"POTRS_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric/hermitian matrices A_l.\nOn exit, if info[l] = 0, the factor L_l or U_l of the Cholesky factorization of A_l returned by\n\\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[inout]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th solution could not be computed.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sposv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dposv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cposv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zposv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRI inverts a symmetric/hermitian positive definite matrix A.\n\n\\details\nThe inverse of matrix \\f$A\\f$ is computed as\n\n\\f[\n\\begin{array}{cl}\nA^{-1} = U^{-1} {U^{-1}}' & \\: \\text{if uplo is upper, or}\\\\\nA^{-1} = {L^{-1}}' L^{-1} & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nwhere \\f$U\\f$ or \\f$L\\f$ is the triangular factor of the Cholesky factorization of \\f$A\\f$ returned by\n\\ref rocsolver_spotrf \"POTRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the factor L or U of the Cholesky factorization of A returned by\n\\ref rocsolver_spotrf \"POTRF\".\nOn exit, the inverse of A if info = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit for inversion of A.\nIf info = i > 0, A is singular. L[i,i] or U[i,i] is zero."]
    pub fn rocsolver_spotri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRI_BATCHED inverts a batch of symmetric/hermitian positive definite matrices \\f$A_l\\f$.\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed as\n\n\\f[\n\\begin{array}{cl}\nA_l^{-1} = U_l^{-1} {U_l^{-1}}' & \\: \\text{if uplo is upper, or}\\\\\nA_l^{-1} = {L_l^{-1}}' L_l^{-1} & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is the triangular factor of the Cholesky factorization of \\f$A_l\\f$ returned by\n\\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the factor L_l or U_l of the Cholesky factorization of A_l returned by\n\\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, A_l is singular. L_l[i,i] or U_l[i,i] is zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief POTRI_STRIDED_BATCHED inverts a batch of symmetric/hermitian positive definite matrices \\f$A_l\\f$.\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed as\n\n\\f[\n\\begin{array}{cl}\nA_l^{-1} = U_l^{-1} {U_l^{-1}}' & \\: \\text{if uplo is upper, or}\\\\\nA_l^{-1} = {L_l^{-1}}' L_l^{-1} & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is the triangular factor of the Cholesky factorization of \\f$A_l\\f$ returned by\n\\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the factor L_l or U_l of the Cholesky factorization of A_l returned by\n\\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, A_l is singular. L_l[i,i] or U_l[i,i] is zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dpotri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cpotri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zpotri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVD computes the singular values and optionally the singular\nvectors of a general m-by-n matrix A (Singular Value Decomposition).\n\n\\details\nThe SVD of matrix A is given by:\n\n\\f[\nA = U  S  V'\n\\f]\n\nwhere the m-by-n matrix S is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of A. U and V are orthogonal\n(unitary) matrices. The first min(m,n) columns of U and V are the left and\nright singular vectors of A, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of V'.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix U (or V') is computed,\n- rocblas_svect_singular: only the singular vectors (first min(m,n)\ncolumns of U or rows of V') are computed,\n- rocblas_svect_overwrite: the first\ncolumns (or rows) of A are overwritten with the singular vectors, or\n- rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.\nno singular vectors.\n\nleft_svect and right_svect cannot both be set to overwrite. When neither is\nset to overwrite, the contents of A are destroyed by the time the function\nreturns.\n\n\\note\nWhen m >> n (or n >> m) the algorithm could be sped up by compressing\nthe matrix A via a QR (or LQ) factorization, and working with the triangular\nfactor afterwards (thin-SVD). If the singular vectors are also requested, its\ncomputation could be sped up as well via executing some intermediate\noperations out-of-place, and relying more on matrix multiplications (GEMMs);\nthis will require, however, a larger memory workspace. The parameter fast_alg\ncontrols whether the fast algorithm is executed or not. For more details, see\nthe \"Tuning rocSOLVER performance\" and \"Memory model\" sections of the documentation.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, if left_svect (or right_svect) is equal to overwrite,\nthe first columns (or rows) contain the left (or right) singular vectors;\notherwise, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A.\n@param[out]\nS           pointer to real type. Array on the GPU of dimension min(m,n).\nThe singular values of A in decreasing order.\n@param[out]\nU           pointer to type. Array on the GPU of dimension ldu*min(m,n) if\nleft_svect is set to singular, or ldu*m when left_svect is equal to all.\nThe matrix of left singular vectors stored as columns. Not\nreferenced if left_svect is set to overwrite or none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.\nThe leading dimension of U.\n@param[out]\nV           pointer to type. Array on the GPU of dimension ldv*n.\nThe matrix of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to overwrite or none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension min(m,n)-1.\nThis array is used to work internally with the bidiagonal matrix\nB associated with A (using \\ref rocsolver_sbdsqr \"BDSQR\"). On exit, if info > 0, it contains the\nunconverged off-diagonal elements of B (or properly speaking, a bidiagonal\nmatrix orthogonally equivalent to B). The diagonal elements of this matrix\nare in S; those that converged correspond to a subset of the singular values\nof A (not necessarily ordered).\n@param[in]\nfast_alg    #rocblas_workmode.\nIf set to rocblas_outofplace, the function will execute the\nfast thin-SVD version of the algorithm when possible.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, \\ref rocsolver_sbdsqr \"BDSQR\" did not converge. i elements of E did not converge to zero."]
    pub fn rocsolver_sgesvd(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        S: *mut f32,
        U: *mut f32,
        ldu: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        E: *mut f32,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvd(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        S: *mut f64,
        U: *mut f64,
        ldu: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        E: *mut f64,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvd(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        S: *mut f32,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        E: *mut f32,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvd(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        S: *mut f64,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        E: *mut f64,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVD_BATCHED computes the singular values and optionally the\nsingular vectors of a batch of general m-by-n matrices A_l (Singular Value\nDecomposition).\n\n\\details\nThe SVD of matrix A_l in the batch is given by:\n\n\\f[\nA_l^{} = U_l^{}  S_l^{}  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$ is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$. \\f$U_l\\f$ and \\f$V_l\\f$ are\northogonal (unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$ and \\f$V_l\\f$ are\nthe left and right singular vectors of \\f$A_l\\f$, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix \\f$U_l\\f$ (or \\f$V_l'\\f$) is computed,\n- rocblas_svect_singular: only the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$ or rows of \\f$V_l'\\f$) are computed,\n- rocblas_svect_overwrite: the\nfirst columns (or rows) of \\f$A_l\\f$ are overwritten with the singular vectors, or\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$ (or \\f$V_l'\\f$) are computed,\ni.e. no singular vectors.\n\nleft_svect and right_svect cannot both be set to overwrite. When neither is\nset to overwrite, the contents of \\f$A_l\\f$ are destroyed by the time the function\nreturns.\n\n\\note\nWhen m >> n (or n >> m) the algorithm could be sped up by compressing\nthe matrix \\f$A_l\\f$ via a QR (or LQ) factorization, and working with the\ntriangular factor afterwards (thin-SVD). If the singular vectors are also\nrequested, its computation could be sped up as well via executing some\nintermediate operations out-of-place, and relying more on matrix\nmultiplications (GEMMs); this will require, however, a larger memory\nworkspace. The parameter fast_alg controls whether the fast algorithm is\nexecuted or not. For more details, see the \"Tuning rocSOLVER performance\"\nand \"Memory model\" sections of the documentation.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on\nthe GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, if left_svect (or right_svect) is equal to overwrite,\nthe first columns (or rows) of A_l contain the left (or right)\ncorresponding singular vectors; otherwise, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe singular values of A_l in decreasing order.\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(l+1).\nThere is no restriction for the value of strideS.\nNormal use case is strideS >= min(m,n).\n@param[out]\nU           pointer to type. Array on the GPU (the side depends on the value of strideU).\nThe matrices U_l of left singular vectors stored as columns.\nNot referenced if left_svect is set to overwrite or none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(l+1).\nThere is no restriction for the value of strideU.\nNormal use case is strideU >= ldu*min(m,n) if left_svect is set to singular,\nor strideU >= ldu*m when left_svect is equal to all.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrices V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to overwrite or none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if\nright_svect is set to singular; or ldv >= 1 otherwise.\nThe leading dimension of V_l.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(l+1).\nThere is no restriction for the value of strideV.\nNormal use case is strideV >= ldv*n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the bidiagonal matrix B_l associated with A_l (using \\ref rocsolver_sbdsqr \"BDSQR\").\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of B_l (or properly speaking,\na bidiagonal matrix orthogonally equivalent to B_l). The diagonal elements of this matrix are in S_l;\nthose that converged correspond to a subset of the singular values of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[in]\nfast_alg    #rocblas_workmode.\nIf set to rocblas_outofplace, the function will execute the fast thin-SVD version\nof the algorithm when possible.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, \\ref rocsolver_sbdsqr \"BDSQR\" did not converge. i elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvd_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvd_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvd_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvd_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVD_STRIDED_BATCHED computes the singular values and optionally the\nsingular vectors of a batch of general m-by-n matrices A_l (Singular Value\nDecomposition).\n\n\\details\nThe SVD of matrix A_l in the batch is given by:\n\n\\f[\nA_l^{} = U_l^{}  S_l^{}  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$ is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$. \\f$U_l\\f$ and \\f$V_l\\f$ are\northogonal (unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$ and \\f$V_l\\f$ are\nthe left and right singular vectors of \\f$A_l\\f$, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix \\f$U_l\\f$ (or \\f$V_l'\\f$) is computed,\n- rocblas_svect_singular: only the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$ or rows of \\f$V_l'\\f$) are computed,\n- rocblas_svect_overwrite: the\nfirst columns (or rows) of \\f$A_l\\f$ are overwritten with the singular vectors, or\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$ (or \\f$V_l'\\f$) are computed,\ni.e. no singular vectors.\n\nleft_svect and right_svect cannot both be set to overwrite. When neither is\nset to overwrite, the contents of \\f$A_l\\f$ are destroyed by the time the function\nreturns.\n\n\\note\nWhen m >> n (or n >> m) the algorithm could be sped up by compressing\nthe matrix \\f$A_l\\f$ via a QR (or LQ) factorization, and working with the\ntriangular factor afterwards (thin-SVD). If the singular vectors are also\nrequested, its computation could be sped up as well via executing some\nintermediate operations out-of-place, and relying more on matrix\nmultiplications (GEMMs); this will require, however, a larger memory\nworkspace. The parameter fast_alg controls whether the fast algorithm is\nexecuted or not. For more details, see the \"Tuning rocSOLVER performance\"\nand \"Memory model\" sections of the documentation.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, if left_svect (or right_svect) is equal to\noverwrite, the first columns (or rows) of A_l contain the left (or right)\ncorresponding singular vectors; otherwise, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA.\nNormal use case is strideA >= lda*n.\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe singular values of A_l in decreasing order.\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(l+1).\nThere is no restriction for the value of strideS.\nNormal use case is strideS >= min(m,n).\n@param[out]\nU           pointer to type. Array on the GPU (the side depends on the value of strideU).\nThe matrices U_l of left singular vectors stored as columns.\nNot referenced if left_svect is set to overwrite or none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(l+1).\nThere is no restriction for the value of strideU.\nNormal use case is strideU >= ldu*min(m,n) if left_svect is set to singular,\nor strideU >= ldu*m when left_svect is equal to all.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrices V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to overwrite or none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V_l.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(l+1).\nThere is no restriction for the value of strideV.\nNormal use case is strideV >= ldv*n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the bidiagonal matrix B_l associated with A_l (using \\ref rocsolver_sbdsqr \"BDSQR\").\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of B_l (or properly speaking,\na bidiagonal matrix orthogonally equivalent to B_l). The diagonal elements of this matrix are in S_l;\nthose that converged correspond to a subset of the singular values of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE.\nNormal use case is strideE >= min(m,n)-1.\n@param[in]\nfast_alg    #rocblas_workmode.\nIf set to rocblas_outofplace, the function will execute the fast thin-SVD version\nof the algorithm when possible.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, BDSQR did not converge. i elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvd_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvd_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvd_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvd_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVDJ computes the singular values and optionally the singular\nvectors of a general m-by-n matrix A (Singular Value Decomposition).\n\n\\details\nThe SVD of matrix A is given by:\n\n\\f[\nA = U  S  V'\n\\f]\n\nwhere the m-by-n matrix S is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of A. U and V are orthogonal\n(unitary) matrices. The first min(m,n) columns of U and V are the left and\nright singular vectors of A, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of V'.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix U (or V') is computed,\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of U or rows of V') are computed, or\n- rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.\nno singular vectors.\n\nThe singular values are computed by applying QR factorization to AV if m >= n\n(resp. LQ factorization to U'A if m < n), where V (resp. U) is found as the\neigenvectors of A'A (resp. AA') using the Jacobi eigenvalue algorithm.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A'A)\nis <= norm(A'A) * abstol [resp. off(AA') <= norm(AA') * abstol]. If abstol <= 0,\nthen the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A'A (resp. AA') at the final\niteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nS           pointer to real type. Array on the GPU of dimension min(m,n).\nThe singular values of A in decreasing order.\n@param[out]\nU           pointer to type. Array on the GPU of dimension ldu*min(m,n) if\nleft_svect is set to singular, or ldu*m when left_svect is equal to all.\nThe matrix of left singular vectors stored as columns. Not\nreferenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.\nThe leading dimension of U.\n@param[out]\nV           pointer to type. Array on the GPU of dimension ldv*n.\nThe matrix of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_sgesvdj(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        U: *mut f32,
        ldu: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvdj(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        U: *mut f64,
        ldu: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvdj(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvdj(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVDJ_BATCHED computes the singular values and optionally the\nsingular vectors of a batch of general m-by-n matrix A (Singular Value\nDecomposition).\n\n\\details\nThe SVD of matrix A_l in the batch is given by:\n\n\\f[\nA_l = U_l  S_l  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$ is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$. \\f$U_l\\f$ and \\f$V_l\\f$ are\northogonal (unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$ and \\f$V_l\\f$ are\nthe left and right singular vectors of \\f$A_l\\f$, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix \\f$U_l\\f$ (or \\f$V_l'\\f$) is computed,\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$ or rows of \\f$V_l'\\f$) are computed, or\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$ (or \\f$V_l'\\f$) are computed,\ni.e. no singular vectors.\n\nThe singular values are computed by applying QR factorization to \\f$A_lV_l\\f$ if m >= n\n(resp. LQ factorization to \\f$U_l'A_l\\f$ if m < n), where \\f$V_l\\f$ (resp. \\f$U_l\\f$) is\nfound as the eigenvectors of \\f$A_l'A_l\\f$ (resp. \\f$A_lA_l'\\f$) using the Jacobi\neigenvalue algorithm.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on\nthe GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l'A_l)\nis <= norm(A_l'A_l) * abstol [resp. off(A_lA_l') <= norm(A_lA_l') * abstol]. If abstol <= 0,\nthen the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l'A_l (resp. A_lA_l') at the final\niteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe singular values of A_l in decreasing order.\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S(l+1).\nThere is no restriction for the value of strideS.\nNormal use case is strideS >= min(m,n).\n@param[out]\nU           pointer to type. Array on the GPU (the side depends on the value of strideU).\nThe matrices U_l of left singular vectors stored as columns.\nNot referenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U(l+1).\nThere is no restriction for the value of strideU.\nNormal use case is strideU >= ldu*min(m,n) if left_svect is set to singular,\nor strideU >= ldu*m when left_svect is equal to all.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrices V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V(l+1).\nThere is no restriction for the value of strideV.\nNormal use case is strideV >= ldv*n.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvdj_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvdj_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvdj_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvdj_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVDJ_STRIDED_BATCHED computes the singular values and optionally the\nsingular vectors of a batch of general m-by-n matrix A (Singular Value\nDecomposition).\n\n\\details\nThe SVD of matrix A_l in the batch is given by:\n\n\\f[\nA_l = U_l  S_l  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$ is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$. \\f$U_l\\f$ and \\f$V_l\\f$ are\northogonal (unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$ and \\f$V_l\\f$ are\nthe left and right singular vectors of \\f$A_l\\f$, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix \\f$U_l\\f$ (or \\f$V_l'\\f$) is computed,\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$ or rows of \\f$V_l'\\f$) are computed, or\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$ (or \\f$V_l'\\f$) are computed,\ni.e. no singular vectors.\n\nThe singular values are computed by applying QR factorization to \\f$A_lV_l\\f$ if m >= n\n(resp. LQ factorization to \\f$U_l'A_l\\f$ if m < n), where \\f$V_l\\f$ (resp. \\f$U_l\\f$) is\nfound as the eigenvectors of \\f$A_l'A_l\\f$ (resp. \\f$A_lA_l'\\f$) using the Jacobi\neigenvalue algorithm.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l.\nOn exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA.\nNormal use case is strideA >= lda*n.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l'A_l)\nis <= norm(A_l'A_l) * abstol [resp. off(A_lA_l') <= norm(A_lA_l') * abstol]. If abstol <= 0,\nthen the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l'A_l (resp. A_lA_l') at the final\niteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe singular values of A_l in decreasing order.\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(j+1).\nThere is no restriction for the value of strideS.\nNormal use case is strideS >= min(m,n).\n@param[out]\nU           pointer to type. Array on the GPU (the side depends on the value of strideU).\nThe matrices U_l of left singular vectors stored as columns.\nNot referenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(j+1).\nThere is no restriction for the value of strideU.\nNormal use case is strideU >= ldu*min(m,n) if left_svect is set to singular,\nor strideU >= ldu*m when left_svect is equal to all.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrices V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(j+1).\nThere is no restriction for the value of strideV.\nNormal use case is strideV >= ldv*n.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvdj_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvdj_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvdj_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvdj_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVDX computes a set of singular values and optionally the corresponding singular\nvectors of a general m-by-n matrix A (partial Singular Value Decomposition).\n\n\\details\nThis function computes all the singular values of A, all the singular values in the half-open interval\n\\f$[vl, vu)\\f$, or the il-th through iu-th singular values, depending on the value of srange.\n\nThe full SVD of matrix A is given by:\n\n\\f[\nA = U  S  V'\n\\f]\n\nwhere the m-by-n matrix S is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of A. U and V are orthogonal\n(unitary) matrices. The first min(m,n) columns of U and V are the left and\nright singular vectors of A, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of V'.\n\nleft_svect and right_svect are #rocblas_svect enums that, for this function, can take the\nfollowing values:\n\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of U or rows of V') corresponding to the computed singular values are computed,\n- rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.\nno singular vectors.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies if the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies if the right singular vectors are computed.\n@param[in]\nsrange      #rocblas_srange.\nSpecifies the type of range or interval of the singular values to be computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A.\n@param[in]\nvl          real type. 0 <= vl < vu.\nThe lower bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A or the singular values within a set of indices.\n@param[in]\nvu          real type. 0 <= vl < vu.\nThe upper bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A or the singular values within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A or the singular values in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A or the singular values in a half-open interval.\n@param[out]\nnsv         pointer to a rocblas_int on the GPU.\nThe total number of singular values found. If srange is rocblas_srange_all, nsv = min(m,n).\nIf srange is rocblas_srange_index, nsv = iu - il + 1. Otherwise, 0 <= nsv <= min(m,n).\n@param[out]\nS           pointer to real type. Array on the GPU of dimension nsv.\nThe first nsv elements contain the computed singular values in descending order.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that S is large enough to hold min(m,n) values.\n@param[out]\nU           pointer to type. Array on the GPU of dimension ldu*nsv.\nThe matrix of left singular vectors stored as columns. Not\nreferenced if left_svect is set to none.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that U is large enough to hold min(m,n) columns.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.\nThe leading dimension of U.\n@param[out]\nV           pointer to type. Array on the GPU of dimension ldv*n.\nThe matrix of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= nsv if right_svect is set to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that V is large enough to hold min(m,n) rows.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension min(m,n).\nIf info = 0, the first nsv elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge, as returned by \\ref rocsolver_sbdsvdx \"BDSVDX\".\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, i eigenvectors did not converge in \\ref rocsolver_sbdsvdx \"BDSVDX\"; their\nindices are stored in ifail."]
    pub fn rocsolver_sgesvdx(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        U: *mut f32,
        ldu: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvdx(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        U: *mut f64,
        ldu: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvdx(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvdx(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVDX_BATCHED computes a set of singular values and optionally the corresponding singular\nvectors of a batch of general m-by-n matrices \\f$A_l\\f$ (partial Singular Value Decomposition).\n\n\\details\nThis function computes all the singular values of \\f$A_l\\f$, all the singular values in the half-open interval\n\\f$[vl, vu)\\f$, or the il-th through iu-th singular values, depending on the value of srange.\n\nThe full SVD of matrix \\f$A_l\\f$  is given by:\n\n\\f[\nA_l = U_l  S_l  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$  is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$ . \\f$U_l\\f$  and \\f$V_l\\f$  are orthogonal\n(unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$  and \\f$V_l\\f$  are the left and\nright singular vectors of \\f$A_l\\f$ , respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that, for this function, can take the\nfollowing values:\n\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$  or rows of \\f$V_l'\\f$ ) corresponding to the computed singular values are computed,\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$  (or \\f$V_l'\\f$ ) are computed, i.e.\nno singular vectors.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies if the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies if the right singular vectors are computed.\n@param[in]\nsrange      #rocblas_srange.\nSpecifies the type of range or interval of the singular values to be computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A_l.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nvl          real type. 0 <= vl < vu.\nThe lower bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values within a set of indices.\n@param[in]\nvu          real type. 0 <= vl < vu.\nThe upper bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values in a half-open interval.\n@param[out]\nnsv         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of singular values found. If srange is rocblas_srange_all, nsv[l] = min(m,n).\nIf srange is rocblas_srange_index, nsv[l] = iu - il + 1. Otherwise, 0 <= nsv[l] <= min(m,n).\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe first nsv_l elements contain the computed singular values in descending order.\n(The remaining elements may be used as workspace for internal computations).\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(l+1).\nThere is no restriction for the value of strideS. Normal use case is strideS >= nsv_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that S_l is large enough to hold min(m,n) values.\n@param[out]\nU           pointer to type. Array on the GPU (the size depends on the value of strideU).\nThe matrix U_l of left singular vectors stored as columns. Not\nreferenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(l+1).\nThere is no restriction for the value of strideU. Normal use case is strideU >= ldu*nsv_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that U_l is large enough to hold min(m,n) columns.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrix V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= nsv_l if right_svect is set to singular; or ldv >= 1 otherwise.\nThe leading dimension of V_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that V_l is large enough to hold min(m,n) rows.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(l+1).\nThere is no restriction for the value of strideV. Normal use case is strideV >= ldv*n.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nsv[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge, as returned by \\ref rocsolver_sbdsvdx \"BDSVDX\".\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= min(m,n).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, i eigenvectors did not converge in \\ref rocsolver_sbdsvdx \"BDSVDX\"; their\nindices are stored in ifail_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvdx_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvdx_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvdx_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvdx_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GESVDX_STRIDED_BATCHED computes a set of singular values and optionally the corresponding singular\nvectors of a batch of general m-by-n matrices \\f$A_l\\f$ (partial Singular Value Decomposition).\n\n\\details\nThis function computes all the singular values of \\f$A_l\\f$, all the singular values in the half-open interval\n\\f$[vl, vu)\\f$, or the il-th through iu-th singular values, depending on the value of srange.\n\nThe full SVD of matrix \\f$A_l\\f$  is given by:\n\n\\f[\nA_l = U_l  S_l  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$  is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$ . \\f$U_l\\f$  and \\f$V_l\\f$  are orthogonal\n(unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$  and \\f$V_l\\f$  are the left and\nright singular vectors of \\f$A_l\\f$ , respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that, for this function, can take the\nfollowing values:\n\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$  or rows of \\f$V_l'\\f$ ) corresponding to the computed singular values are computed,\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$  (or \\f$V_l'\\f$ ) are computed, i.e.\nno singular vectors.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies if the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies if the right singular vectors are computed.\n@param[in]\nsrange      #rocblas_srange.\nSpecifies the type of range or interval of the singular values to be computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A_l.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l.\nOn exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nvl          real type. 0 <= vl < vu.\nThe lower bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values within a set of indices.\n@param[in]\nvu          real type. 0 <= vl < vu.\nThe upper bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values in a half-open interval.\n@param[out]\nnsv         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of singular values found. If srange is rocblas_srange_all, nsv[l] = min(m,n).\nIf srange is rocblas_srange_index, nsv[l] = iu - il + 1. Otherwise, 0 <= nsv[l] <= min(m,n).\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe first nsv_l elements contain the computed singular values in descending order.\n(The remaining elements may be used as workspace for internal computations).\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(l+1).\nThere is no restriction for the value of strideS. Normal use case is strideS >= nsv_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that S_l is large enough to hold min(m,n) values.\n@param[out]\nU           pointer to type. Array on the GPU (the size depends on the value of strideU).\nThe matrix U_l of left singular vectors stored as columns. Not\nreferenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(l+1).\nThere is no restriction for the value of strideU. Normal use case is strideU >= ldu*nsv_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that U_l is large enough to hold min(m,n) columns.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrix V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= nsv_l if right_svect is set to singular; or ldv >= 1 otherwise.\nThe leading dimension of V_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that V_l is large enough to hold min(m,n) rows.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(l+1).\nThere is no restriction for the value of strideV. Normal use case is strideV >= ldv*n.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nsv[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge, as returned by \\ref rocsolver_sbdsvdx \"BDSVDX\".\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= min(m,n).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, i eigenvectors did not converge in \\ref rocsolver_sbdsvdx \"BDSVDX\"; their\nindices are stored in ifail_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvdx_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgesvdx_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgesvdx_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgesvdx_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTD2 computes the tridiagonal form of a real symmetric matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form is given by:\n\n\\f[\nT = Q'  A  Q\n\\f]\n\nwhere T is symmetric tridiagonal and Q is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ = H(n-1)H(n-2)\\cdots H(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i] \\cdot v_i^{}  v_i'\n\\f]\n\nwhere tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_i stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_i stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nThe diagonal elements of T.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of T.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars."]
    pub fn rocsolver_ssytd2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tau: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytd2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tau: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HETD2 computes the tridiagonal form of a complex hermitian matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form is given by:\n\n\\f[\nT = Q'  A  Q\n\\f]\n\nwhere T is hermitian tridiagonal and Q is an unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ = H(n-1)H(n-2)\\cdots H(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i] \\cdot v_i^{}  v_i'\n\\f]\n\nwhere tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T; the elements above the superdiagonal contain\nthe first i-1 elements of the Householders vector v_i stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_i stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of T.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of T.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars."]
    pub fn rocsolver_chetd2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tau: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhetd2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tau: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTD2_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is symmetric tridiagonal and \\f$Q_l\\f$ is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l^{}[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytd2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytd2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HETD2_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is Hermitian tridiagonal and \\f$Q_l\\f$ is a unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch.\n"]
    pub fn rocsolver_chetd2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhetd2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTD2_STRIDED_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is symmetric tridiagonal and \\f$Q_l\\f$ is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytd2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytd2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HETD2_STRIDED_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is Hermitian tridiagonal and \\f$Q_l\\f$ is a unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chetd2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhetd2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTRD computes the tridiagonal form of a real symmetric matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form is given by:\n\n\\f[\nT = Q'  A  Q\n\\f]\n\nwhere T is symmetric tridiagonal and Q is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H_(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ = H(n-1)H(n-2)\\cdots H(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i] \\cdot v_i^{}  v_i'\n\\f]\n\nwhere tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_i stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_i stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nThe diagonal elements of T.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of T.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars."]
    pub fn rocsolver_ssytrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tau: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tau: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HETRD computes the tridiagonal form of a complex hermitian matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form is given by:\n\n\\f[\nT = Q'  A  Q\n\\f]\n\nwhere T is hermitian tridiagonal and Q is an unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ = H(n-1)H(n-2)\\cdots H(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i] \\cdot v_i^{}  v_i'\n\\f]\n\nwhere tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_i stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_i stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of T.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of T.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars."]
    pub fn rocsolver_chetrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tau: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhetrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tau: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTRD_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is symmetric tridiagonal and \\f$Q_l\\f$ is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytrd_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytrd_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HETRD_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is Hermitian tridiagonal and \\f$Q_l\\f$ is a unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE          pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chetrd_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhetrd_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTRD_STRIDED_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is symmetric tridiagonal and \\f$Q_l\\f$ is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytrd_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytrd_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HETRD_STRIDED_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is Hermitian tridiagonal and \\f$Q_l\\f$ is a unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chetrd_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhetrd_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGS2 reduces a real symmetric-definite generalized eigenproblem to standard\nform.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU^{-T} A U^{-1}, & \\: \\text{or}\\\\\nL^{-1} A L^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix B has been factorized as either \\f$U^T U\\f$ or\n\\f$L L^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU A U^T, & \\: \\text{or}\\\\\nL^T A L,\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored, and\nwhether the factorization applied to B was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and\nB are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the transformed matrix associated with\nthe equivalent standard eigenvalue problem.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nThe triangular factor of the matrix B, as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B."]
    pub fn rocsolver_ssygs2(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygs2(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGS2 reduces a hermitian-definite generalized eigenproblem to standard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU^{-H} A U^{-1}, & \\: \\text{or}\\\\\nL^{-1} A L^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix B has been factorized as either \\f$U^H U\\f$ or\n\\f$L L^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU A U^H, & \\: \\text{or}\\\\\nL^H A L,\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored, and\nwhether the factorization applied to B was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and\nB are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the transformed matrix associated with\nthe equivalent standard eigenvalue problem.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nThe triangular factor of the matrix B, as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B."]
    pub fn rocsolver_chegs2(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegs2(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGS2_BATCHED reduces a batch of real symmetric-definite generalized eigenproblems\nto standard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-T} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^T U_l^{}\\f$ or\n\\f$L_l^{} L_l^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^T, & \\: \\text{or}\\\\\nL_l^T A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygs2_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygs2_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGS2_BATCHED reduces a batch of hermitian-definite generalized eigenproblems to\nstandard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-H} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^H U_l^{}\\f$ or\n\\f$L_l^{} L_l^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^H, & \\: \\text{or}\\\\\nL_l^H A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegs2_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegs2_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGS2_STRIDED_BATCHED reduces a batch of real symmetric-definite generalized\neigenproblems to standard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-T} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^T U_l^{}\\f$ or\n\\f$L_l^{} L_l^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^T, & \\: \\text{or}\\\\\nL_l^T A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*n.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygs2_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygs2_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGS2_STRIDED_BATCHED reduces a batch of hermitian-definite generalized\neigenproblems to standard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-H} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^H U_l^{}\\f$ or\n\\f$L_l^{} L_l^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^H, & \\: \\text{or}\\\\\nL_l^H A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*n.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegs2_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegs2_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGST reduces a real symmetric-definite generalized eigenproblem to standard\nform.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU^{-T} A U^{-1}, & \\: \\text{or}\\\\\nL^{-1} A L^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix B has been factorized as either \\f$U^T U\\f$ or\n\\f$L L^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU A U^T, & \\: \\text{or}\\\\\nL^T A L,\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored, and\nwhether the factorization applied to B was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and\nB are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the transformed matrix associated with\nthe equivalent standard eigenvalue problem.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nThe triangular factor of the matrix B, as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B."]
    pub fn rocsolver_ssygst(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygst(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGST reduces a hermitian-definite generalized eigenproblem to standard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU^{-H} A U^{-1}, & \\: \\text{or}\\\\\nL^{-1} A L^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix B has been factorized as either \\f$U^H U\\f$ or\n\\f$L L^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU A U^H, & \\: \\text{or}\\\\\nL^H A L,\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored, and\nwhether the factorization applied to B was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and\nB are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the transformed matrix associated with\nthe equivalent standard eigenvalue problem.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nThe triangular factor of the matrix B, as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B."]
    pub fn rocsolver_chegst(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegst(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGST_BATCHED reduces a batch of real symmetric-definite generalized eigenproblems\nto standard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-T} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^T U_l^{}\\f$ or\n\\f$L_l^{} L_l^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^T, & \\: \\text{or}\\\\\nL_l^T A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygst_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygst_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGST_BATCHED reduces a batch of hermitian-definite generalized eigenproblems to\nstandard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-H} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^H U_l^{}\\f$ or\n\\f$L_l^{} L_l^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^H, & \\: \\text{or}\\\\\nL_l^H A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegst_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegst_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGST_STRIDED_BATCHED reduces a batch of real symmetric-definite generalized\neigenproblems to standard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-T} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^T U_l^{}\\f$ or\n\\f$L_l^{} L_l^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^T, & \\: \\text{or}\\\\\nL_l^T A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*n.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygst_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygst_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGST_STRIDED_BATCHED reduces a batch of hermitian-definite generalized\neigenproblems to standard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-H} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^H U_l^{}\\f$ or\n\\f$L_l^{} L_l^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^H, & \\: \\text{or}\\\\\nL_l^H A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*n.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegst_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegst_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEV computes the eigenvalues and optionally the eigenvectors of a real symmetric\nmatrix A.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with A.\nOn exit, if info > 0, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues of A (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = i > 0, the algorithm did not converge.\ni elements of E did not converge to zero."]
    pub fn rocsolver_ssyev(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyev(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEV computes the eigenvalues and optionally the eigenvectors of a Hermitian matrix A.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with A.\nOn exit, if info > 0, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues of A (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = i > 0, the algorithm did not converge.\ni elements of E did not converge to zero."]
    pub fn rocsolver_cheev(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheev(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEV_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.\ni elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyev_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyev_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEV_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nHermitian matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.\ni elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheev_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheev_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEV_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.\ni elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyev_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyev_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEV_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nHermitian matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.\ni elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheev_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheev_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVD computes the eigenvalues and optionally the eigenvectors of a real symmetric\nmatrix A.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with A.\nOn exit, if info > 0, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues of A (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E did not converge to zero.\nIf info = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)]."]
    pub fn rocsolver_ssyevd(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevd(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVD computes the eigenvalues and optionally the eigenvectors of a Hermitian matrix A.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with A.\nOn exit, if info > 0, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues of A (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E did not converge to zero.\nIf info = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)]."]
    pub fn rocsolver_cheevd(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevd(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVD_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E_l did not converge to zero.\nIf info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevd_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevd_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVD_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nHermitian matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E_l did not converge to zero.\nIf info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevd_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevd_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVD_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E_l did not converge to zero.\nIf info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevd_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevd_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVD_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nHermitian matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E_l did not converge to zero.\nIf info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevd_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevd_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVDJ computes the eigenvalues and optionally the eigenvectors of a real symmetric\nmatrix A.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\\n\nThe eigenvalues of A in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\\n\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_ssyevdj(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevdj(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVDJ computes the eigenvalues and optionally the eigenvectors of a complex Hermitian\nmatrix A.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the Hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\\n\nThe eigenvalues of A in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\\n\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_cheevdj(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevdj(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVDJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a\nbatch of real symmetric matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit for A_l. If info[l] = 1, the algorithm did not converge for A_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevdj_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevdj_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVDJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a\nbatch of complex Hermitian matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit for A_l. If info[l] = 1, the algorithm did not converge for A_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevdj_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevdj_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVDJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a\nbatch of real symmetric matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\\n\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit for A_l. If info[l] = 1, the algorithm did not converge for A_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevdj_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevdj_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVDJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a\nbatch of complex Hermitian matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\\n\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit for A_l. If info[l] = 1, the algorithm did not converge for A_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevdj_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevdj_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVDJ computes the eigenvalues and (optionally) eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A and B are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and B\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A. On exit, the normalized matrix Z of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrix A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*n.\\n\nOn entry, the symmetric positive definite matrix B. On exit,\nthe triangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrix B.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\\n\nThe eigenvalues in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\\n\nIf info = 0, successful exit. If info = 1, the algorithm did not converge.\nIf info = n + i, the leading minor of order i of B is not positive definite."]
    pub fn rocsolver_ssygvdj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvdj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVDJ computes the eigenvalues and (optionally) eigenvectors of\na complex generalized Hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A and B are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and B\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A. On exit, the normalized matrix Z of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrix A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*n.\\n\nOn entry, the Hermitian positive definite matrix B. On exit,\nthe triangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrix B.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\\n\nThe eigenvalues in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\\n\nIf info = 0, successful exit. If info = 1, the algorithm did not converge.\nIf info = n + i, the leading minor of order i of B is not positive definite."]
    pub fn rocsolver_chegvdj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvdj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVDJ_BATCHED computes the eigenvalues and (optionally) eigenvectors of\nbatch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z_l of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T_l B_l Z_l=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T_l B^{-1}_l Z_l=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A_l and B_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and B_l\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_l. On exit, the normalized matrices Z_l of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[inout]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\\n\nOn entry, the symmetric positive definite matrices B_l. On exit,\nthe triangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrices B_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge for matrix A_l.\nIf info[l] = n + i, the leading minor of order i of B_l is not positive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of eigenproblems in the batch."]
    pub fn rocsolver_ssygvdj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvdj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVDJ_BATCHED computes the eigenvalues and (optionally) eigenvectors of\nbatch of complex generalized Hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z_l of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H_l B_l Z_l=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H_l B^{-1}_l Z_l=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A_l and B_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and B_l\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_l. On exit, the normalized matrices Z_l of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[inout]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\\n\nOn entry, the Hermitian positive definite matrices B_l. On exit,\nthe triangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrices B_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge for matrix A_l.\nIf info[l] = n + i, the leading minor of order i of B_l is not positive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of eigenproblems in the batch."]
    pub fn rocsolver_chegvdj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvdj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVDJ_STRIDED_BATCHED computes the eigenvalues and (optionally) eigenvectors of\nbatch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z_l of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T_l B_l Z_l=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T_l B^{-1}_l Z_l=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A_l and B_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and B_l\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_l. On exit, the normalized matrices Z_l of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\\n\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\\n\nOn entry, the symmetric positive definite matrices B_l. On exit,\nthe triangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\\n\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge for matrix A_l.\nIf info[l] = n + i, the leading minor of order i of B_l is not positive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of eigenproblems in the batch."]
    pub fn rocsolver_ssygvdj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvdj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVDJ_STRIDED_BATCHED computes the eigenvalues and (optionally) eigenvectors of\nbatch of complex generalized Hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z_l of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H_l B_l Z_l=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H_l B^{-1}_l Z_l=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A_l and B_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and B_l\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_l. On exit, the normalized matrices Z_l of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\\n\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\\n\nOn entry, the Hermitian positive definite matrices B_l. On exit,\nthe triangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\\n\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge for matrix A_l.\nIf info[l] = n + i, the leading minor of order i of B_l is not positive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of eigenproblems in the batch."]
    pub fn rocsolver_chegvdj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvdj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVJ computes the eigenvalues and optionally the eigenvectors of a real symmetric\nmatrix A.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A\\f$ is transformed by a product of Jacobi rotations \\f$V\\f$ as\n\n\\f[\nA^{(k)} = V' A^{(k-1)} V\n\\f]\n\nsuch that \\f$off(A^{(k)}) < off(A^{(k-1)})\\f$, where \\f$A^{(0)} = A\\f$ and \\f$off(A^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A^{(k)}\\f$. As \\f$off(A^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A (i.e. off(A)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_ssyevj(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevj(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVJ computes the eigenvalues and optionally the eigenvectors of a complex Hermitian\nmatrix A.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A\\f$ is transformed by a product of Jacobi rotations \\f$V\\f$ as\n\n\\f[\nA^{(k)} = V' A^{(k-1)} V\n\\f]\n\nsuch that \\f$off(A^{(k)}) < off(A^{(k-1)})\\f$, where \\f$A^{(0)} = A\\f$ and \\f$off(A^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A^{(k)}\\f$. As \\f$off(A^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A (i.e. off(A)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_cheevj(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevj(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A_l\\f$ is transformed by a product of Jacobi rotations \\f$V_l\\f$ as\n\n\\f[\nA_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}\n\\f]\n\nsuch that \\f$off(A_l^{(k)}) < off(A_l^{(k-1)})\\f$, where \\f$A_l^{(0)} = A_l\\f$ and \\f$off(A_l^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A_l^{(k)}\\f$. As \\f$off(A_l^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A_l^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevj_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevj_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\ncomplex Hermitian matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A_l\\f$ is transformed by a product of Jacobi rotations \\f$V_l\\f$ as\n\n\\f[\nA_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}\n\\f]\n\nsuch that \\f$off(A_l^{(k)}) < off(A_l^{(k-1)})\\f$, where \\f$A_l^{(0)} = A_l\\f$ and \\f$off(A_l^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A_l^{(k)}\\f$. As \\f$off(A_l^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A_l^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevj_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevj_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A_l\\f$ is transformed by a product of Jacobi rotations \\f$V_l\\f$ as\n\n\\f[\nA_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}\n\\f]\n\nsuch that \\f$off(A_l^{(k)}) < off(A_l^{(k-1)})\\f$, where \\f$A_l^{(0)} = A_l\\f$ and \\f$off(A_l^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A_l^{(k)}\\f$. As \\f$off(A_l^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A_l^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevj_strided_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevj_strided_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\ncomplex Hermitian matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A_l\\f$ is transformed by a product of Jacobi rotations \\f$V_l\\f$ as\n\n\\f[\nA_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}\n\\f]\n\nsuch that \\f$off(A_l^{(k)}) < off(A_l^{(k-1)})\\f$, where \\f$A_l^{(0)} = A_l\\f$ and \\f$off(A_l^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A_l^{(k)}\\f$. As \\f$off(A_l^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A_l^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevj_strided_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevj_strided_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of a\nreal symmetric matrix A.\n\n\\details\nThis function computes all the eigenvalues of A, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the algorithm did not converge. i columns of Z did not converge."]
    pub fn rocsolver_ssyevx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of a\nHermitian matrix A.\n\n\\details\nThis function computes all the eigenvalues of A, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the algorithm did not converge. i columns of Z did not converge."]
    pub fn rocsolver_cheevx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVX_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of real symmetric matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVX_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of Hermitian matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYEVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of real symmetric matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut f32,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsyevx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut f64,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEEVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of Hermitian matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zheevx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGV computes the eigenvalues and (optionally) eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with\nthe reduced eigenvalue problem.\nOn exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygv(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygv(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGV computes the eigenvalues and (optionally) eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the hermitian matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with\nthe reduced eigenvalue problem.\nOn exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegv(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegv(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGV_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygv_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygv_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGV_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegv_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegv_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGV_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch j.\nIf info[l] = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygv_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygv_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGV_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegv_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegv_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVD computes the eigenvalues and (optionally) eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with\nthe reduced eigenvalue problem.\nOn exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygvd(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvd(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVD computes the eigenvalues and (optionally) eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the hermitian matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with\nthe reduced eigenvalue problem.\nOn exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegvd(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvd(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVD_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvd_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvd_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVD_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvd_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvd_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVD_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvd_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvd_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVD_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvd_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvd_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVJ computes the eigenvalues and (optionally) eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = 1, the algorithm did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygvj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVJ computes the eigenvalues and (optionally) eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the hermitian matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = 1, the algorithm did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegvj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVJ_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = 1, the algorithm did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVJ_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = 1, the algorithm did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVJ_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = 1, the algorithm did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVJ_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = 1, the algorithm did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nIf info = i <= n, ifail contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i columns of Z did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygvx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nIf info = i <= n, ifail contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i columns of Z did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegvx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVX_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nIf info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVX_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nIf info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYGVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nIf info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut f32,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsygvx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut f64,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief HEGVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nIf info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zhegvx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_OUTOFPLACE computes the inverse \\f$C = A^{-1}\\f$ of a general n-by-n matrix A.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nAC = I\n\\f]\n\nwhere I is the identity matrix, and A is factorized as \\f$A = PLU\\f$ as given by \\ref rocsolver_sgetrf \"GETRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\nThe factors L and U of the factorization A = P*L*U returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe pivot indices returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[out]\nC           pointer to type. Array on the GPU of dimension ldc*n.\nIf info = 0, the inverse of A. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetri_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_OUTOFPLACE_BATCHED computes the inverse \\f$C_l = A_l^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_l\\f$.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA_l C_l = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_l\\f$ is factorized as \\f$A_l = P_l  L_l  U_l\\f$ as given by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[in]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nThe factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe pivot indices returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\nC           array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.\nIf info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *const *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *const *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_OUTOFPLACE_STRIDED_BATCHED computes the inverse \\f$C_l = A_l^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_l\\f$.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA_l C_l = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_l\\f$ is factorized as \\f$A_l = P_l L_l U_l\\f$ as given by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nThe factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by\n\\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe pivot indices returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nIf info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C_l.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one matrix C_l to the next one C_(l+1).\nThere is no restriction for the value of strideC. Normal use case is strideC >= ldc*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_NPVT_OUTOFPLACE computes the inverse \\f$C = A^{-1}\\f$ of a general n-by-n matrix A without partial pivoting.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nAC = I\n\\f]\n\nwhere I is the identity matrix, and A is factorized as \\f$A = LU\\f$ as given by \\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\nThe factors L and U of the factorization A = L*U returned by \\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nC           pointer to type. Array on the GPU of dimension ldc*n.\nIf info = 0, the inverse of A. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetri_npvt_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_npvt_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_npvt_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_npvt_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_NPVT_OUTOFPLACE_BATCHED computes the inverse \\f$C_l^{} = A_l^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_l\\f$\nwithout partial pivoting.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA_l C_l = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_l\\f$ is factorized as \\f$A_l = L_l  U_l\\f$ as given by \\ref rocsolver_sgetrf_npvt_batched \"GETRF_NPVT_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[in]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nThe factors L_l and U_l of the factorization A_l = L_l*U_l returned by \\ref rocsolver_sgetrf_npvt_batched \"GETRF_NPVT_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nC           array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.\nIf info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_npvt_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_npvt_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_npvt_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_npvt_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GETRI_NPVT_OUTOFPLACE_STRIDED_BATCHED computes the inverse \\f$C_l^{} = A_l^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_l\\f$\nwithout partial pivoting.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA_l C_l = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_l\\f$ is factorized as \\f$A_l = L_l  U_l\\f$ as given by \\ref rocsolver_sgetrf_npvt_strided_batched \"GETRF_NPVT_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nThe factors L_l and U_l of the factorization A_l = L_l*U_l returned by\n\\ref rocsolver_sgetrf_npvt_strided_batched \"GETRF_NPVT_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nIf info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C_l.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one matrix C_l to the next one C_(l+1).\nThere is no restriction for the value of strideC. Normal use case is strideC >= ldc*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_npvt_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgetri_npvt_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgetri_npvt_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgetri_npvt_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief TRTRI inverts a triangular n-by-n matrix A.\n\n\\details\nA can be upper or lower triangular, depending on the value of uplo, and unit or non-unit\ntriangular, depending on the value of diag.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\ndiag        rocblas_diagonal.\nIf diag indicates unit, then the diagonal elements of A are not referenced and\nassumed to be one.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the triangular matrix.\nOn exit, the inverse of A if info = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, A is singular. A[i,i] is the first zero element in the diagonal."]
    pub fn rocsolver_strtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dtrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_ctrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_ztrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief TRTRI_BATCHED inverts a batch of triangular n-by-n matrices \\f$A_l\\f$.\n\n\\details\n\\f$A_l\\f$ can be upper or lower triangular, depending on the value of uplo, and unit or non-unit\ntriangular, depending on the value of diag.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\ndiag        rocblas_diagonal.\nIf diag indicates unit, then the diagonal elements of matrices A_l are not referenced and\nassumed to be one.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the triangular matrices A_l.\nOn exit, the inverses of A_l if info[l] = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, A_l is singular. A_l[i,i] is the first zero element in the diagonal.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_strtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dtrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_ctrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_ztrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief TRTRI_STRIDED_BATCHED inverts a batch of triangular n-by-n matrices \\f$A_l\\f$.\n\n\\details\n\\f$A_l\\f$ can be upper or lower triangular, depending on the value of uplo, and unit or non-unit\ntriangular, depending on the value of diag.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\ndiag        rocblas_diagonal.\nIf diag indicates unit, then the diagonal elements of matrices A_l are not referenced and\nassumed to be one.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the triangular matrices A_l.\nOn exit, the inverses of A_l if info[l] = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, A_l is singular. A_l[i,i] is the first zero element in the diagonal.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_strtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dtrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_ctrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_ztrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTF2 computes the factorization of a symmetric indefinite matrix \\f$A\\f$\nusing Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA = U D U^T & \\: \\text{or}\\\\\nA = L D L^T &\n\\end{array}\n\\f]\n\nwhere \\f$U\\f$ or \\f$L\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_k\\f$.\n\nSpecifically, \\f$U\\f$ and \\f$L\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU = P(n) U(n) \\cdots P(k) U(k) \\cdots & \\: \\text{and}\\\\\nL = P(1) L(1) \\cdots P(k) L(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_k\\f$, and \\f$P(k)\\f$ is a permutation matrix defined by\n\\f$ipiv[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_k\\f$, then \\f$U(k)\\f$\nand \\f$L(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_k\\f$ is stored in \\f$A[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_k\\f$ is stored in \\f$A[k-1,k-1]\\f$, \\f$A[k-1,k]\\f$,\nand \\f$A[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_k\\f$ is stored in \\f$A[k,k]\\f$, \\f$A[k+1,k]\\f$,\nand \\f$A[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A to be factored.\nOn exit, the block diagonal matrix D and the multipliers needed to\ncompute U or L.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv[k] > 0 then rows and columns k and ipiv[k]\nwere interchanged and D[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv[k] = ipiv[k-1] < 0 and uplo is upper (or ipiv[k]\n= ipiv[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv[k] (or rows and columns k+1 and -ipiv[k]) were interchanged\nand D[k-1,k-1] to D[k,k] (or D[k,k] to D[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, D is singular. D[i,i] is the first diagonal zero."]
    pub fn rocsolver_ssytf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_csytf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zsytf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTF2_BATCHED computes the factorization of a batch of symmetric indefinite\nmatrices using Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l^{} D_l^{} U_l^T & \\: \\text{or}\\\\\nA_l^{} = L_l^{} D_l^{} L_l^T &\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D_l\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_{kl}\\f$.\n\nSpecifically, \\f$U_l\\f$ and \\f$L_l\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU_l = P_l(n) U_l(n) \\cdots P_l(k) U_l(k) \\cdots & \\: \\text{and}\\\\\nL_l = P_l(1) L_l(1) \\cdots P_l(k) L_l(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_{kl}\\f$, and \\f$P_l(k)\\f$ is a permutation matrix defined by\n\\f$ipiv_l[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_{kl}\\f$, then \\f$U_l(k)\\f$\nand \\f$L_l(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k-1,k-1]\\f$, \\f$A_l[k-1,k]\\f$,\nand \\f$A_l[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$, \\f$A_l[k+1,k]\\f$,\nand \\f$A_l[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l to be factored.\nOn exit, the block diagonal matrices D_l and the multipliers needed to\ncompute U_l or L_l.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]\nwere interchanged and D_l[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]\n= ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged\nand D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_csytf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zsytf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTF2_STRIDED_BATCHED computes the factorization of a batch of symmetric indefinite\nmatrices using Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l^{} D_l^{} U_l^T & \\: \\text{or}\\\\\nA_l^{} = L_l^{} D_l^{} L_l^T &\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D_l\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_{kl}\\f$.\n\nSpecifically, \\f$U_l\\f$ and \\f$L_l\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU_l = P_l(n) U_l(n) \\cdots P_l(k) U_l(k) \\cdots & \\: \\text{and}\\\\\nL_l = P_l(1) L_l(1) \\cdots P_l(k) L_l(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_{kl}\\f$, and \\f$P_l(k)\\f$ is a permutation matrix defined by\n\\f$ipiv_l[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_{kl}\\f$, then \\f$U_l(k)\\f$\nand \\f$L_l(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k-1,k-1]\\f$, \\f$A_l[k-1,k]\\f$,\nand \\f$A_l[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$, \\f$A_l[k+1,k]\\f$,\nand \\f$A_l[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l to be factored.\nOn exit, the block diagonal matrices D_l and the multipliers needed to\ncompute U_l or L_l.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]\nwere interchanged and D_l[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]\n= ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged\nand D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_csytf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zsytf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTRF computes the factorization of a symmetric indefinite matrix \\f$A\\f$\nusing Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA = U D U^T & \\: \\text{or}\\\\\nA = L D L^T &\n\\end{array}\n\\f]\n\nwhere \\f$U\\f$ or \\f$L\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_k\\f$.\n\nSpecifically, \\f$U\\f$ and \\f$L\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU = P(n) U(n) \\cdots P(k) U(k) \\cdots & \\: \\text{and}\\\\\nL = P(1) L(1) \\cdots P(k) L(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_k\\f$, and \\f$P(k)\\f$ is a permutation matrix defined by\n\\f$ipiv[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_k\\f$, then \\f$U(k)\\f$\nand \\f$L(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_k\\f$ is stored in \\f$A[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_k\\f$ is stored in \\f$A[k-1,k-1]\\f$, \\f$A[k-1,k]\\f$,\nand \\f$A[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_k\\f$ is stored in \\f$A[k,k]\\f$, \\f$A[k+1,k]\\f$,\nand \\f$A[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A to be factored.\nOn exit, the block diagonal matrix D and the multipliers needed to\ncompute U or L.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv[k] > 0 then rows and columns k and ipiv[k]\nwere interchanged and D[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv[k] = ipiv[k-1] < 0 and uplo is upper (or ipiv[k]\n= ipiv[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv[k] (or rows and columns k+1 and -ipiv[k]) were interchanged\nand D[k-1,k-1] to D[k,k] (or D[k,k] to D[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, D is singular. D[i,i] is the first diagonal zero."]
    pub fn rocsolver_ssytrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_csytrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zsytrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTRF_BATCHED computes the factorization of a batch of symmetric indefinite\nmatrices using Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l^{} D_l^{} U_l^T & \\: \\text{or}\\\\\nA_l^{} = L_l^{} D_l^{} L_l^T &\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D_l\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_{kl}\\f$.\n\nSpecifically, \\f$U_l\\f$ and \\f$L_l\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU_l = P_l(n) U_l(n) \\cdots P_l(k) U_l(k) \\cdots & \\: \\text{and}\\\\\nL_l = P_l(1) L_l(1) \\cdots P_l(k) L_l(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_{kl}\\f$, and \\f$P_l(k)\\f$ is a permutation matrix defined by\n\\f$ipiv_l[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_{kl}\\f$, then \\f$U_l(k)\\f$\nand \\f$L_l(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k-1,k-1]\\f$, \\f$A_l[k-1,k]\\f$,\nand \\f$A_l[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$, \\f$A_l[k+1,k]\\f$,\nand \\f$A_l[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l to be factored.\nOn exit, the block diagonal matrices D_l and the multipliers needed to\ncompute U_l or L_l.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]\nwere interchanged and D_l[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]\n= ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged\nand D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_csytrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zsytrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief SYTRF_STRIDED_BATCHED computes the factorization of a batch of symmetric indefinite\nmatrices using Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l^{} D_l^{} U_l^T & \\: \\text{or}\\\\\nA_l^{} = L_l^{} D_l^{} L_l^T &\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D_l\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_{kl}\\f$.\n\nSpecifically, \\f$U_l\\f$ and \\f$L_l\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU_l = P_l(n) U_l(n) \\cdots P_l(k) U_l(k) \\cdots & \\: \\text{and}\\\\\nL_l = P_l(1) L_l(1) \\cdots P_l(k) L_l(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_{kl}\\f$, and \\f$P_l(k)\\f$ is a permutation matrix defined by\n\\f$ipiv_l[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_{kl}\\f$, then \\f$U_l(k)\\f$\nand \\f$L_l(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k-1,k-1]\\f$, \\f$A_l[k-1,k]\\f$,\nand \\f$A_l[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_l(k)\\f$ is stored in \\f$A_l[k,k]\\f$, \\f$A_l[k+1,k]\\f$,\nand \\f$A_l[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l to be factored.\nOn exit, the block diagonal matrices D_l and the multipliers needed to\ncompute U_l or L_l.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]\nwere interchanged and D_l[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]\n= ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged\nand D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dsytrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_csytrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zsytrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = "! @}\n*! @{\n\\brief GEBLTTRF_NPVT computes the LU factorization of a block tridiagonal matrix without partial pivoting.\n\n\\details The LU factorization of a block tridiagonal matrix\n\n\\f[\nM = \\left[\\begin{array}{ccccc}\nB_1 & C_1\\\\\nA_1 & B_2 & C_2\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{n-2} & B_{n-1} & C_{n-1}\\\\\n&  &  & A_{n-1} & B_n\n\\end{array}\\right]\n\\f]\n\nwith \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, can be represented as\n\n\\f[\nM = \\left[\\begin{array}{cccc}\nL_1 \\\\\nA_1 & L_2\\\\\n& \\ddots & \\ddots \\\\\n&  & A_{n-1} & L_n\n\\end{array}\\right] \\left[\\begin{array}{cccc}\nI & U_1 \\\\\n& \\ddots & \\ddots \\\\\n&  & I & U_{n-1}\\\\\n&  &  & I\n\\end{array}\\right] = LU\n\\f]\n\nwhere the blocks \\f$L_i\\f$ and \\f$U_i\\f$ are also general blocks of size nb.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of the matrix.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*nb*(nblocks-1).\nContains the blocks A_i arranged one after the other.\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_i.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nb*nblocks.\nOn entry, contains the blocks B_i arranged one after the other.\nOn exit it is overwritten by blocks L_i in factorized form as returned by\n\\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\"\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_i.\n@param[inout]\nC           pointer to type. Array on the GPU of dimension ldc*nb*(nblocks-1).\nOn entry, contains the blocks C_i arranged one after the other.\nOn exit it is overwritten by blocks U_i.\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_i.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the matrix is singular.\n********************************************************************/"]
    pub fn rocsolver_sgeblttrf_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeblttrf_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeblttrf_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeblttrf_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBLTTRF_NPVT_BATCHED computes the LU factorization of a batch of block tridiagonal matrices without\npartial pivoting.\n\n\\details The LU factorization of a block tridiagonal matrix \\f$M_l\\f$ in the batch\n\n\\f[\nM_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(l-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\n\\f]\n\nwith \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, can be represented as\n\n\\f[\nM_l = \\left[\\begin{array}{cccc}\nL_{l1} \\\\\nA_{l1} & L_{l2}\\\\\n& \\ddots & \\ddots \\\\\n&  & A_{l(n-1)} & L_{ln}\n\\end{array}\\right] \\left[\\begin{array}{cccc}\nI & U_{l1} \\\\\n& \\ddots & \\ddots \\\\\n&  & I & U_{l(n-1)}\\\\\n&  &  & I\n\\end{array}\\right] = L_lU_l\n\\f]\n\nwhere the blocks \\f$L_{li}\\f$ and \\f$U_{li}\\f$ are also general blocks of size nb.\n\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension\nlda*nb*(nblocks-1).\nContains the blocks A_{li} arranged one after the other.\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_{li}.\n@param[inout]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension\nldb*nb*nblocks.\nOn entry, contains the blocks B_{li} arranged one after the other.\nOn exit it is overwritten by blocks L_{li} in factorized form as returned by\n\\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\"\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_{li}.\n@param[inout]\nC           array of pointers to type. Each pointer points to an array on the GPU of dimension\nldc*nb*(nblocks-1).\nOn entry, contains the blocks C_{li} arranged one after the other.\nOn exit it is overwritten by blocks U_{li}.\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_{li}.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of l-th batch instance.\nIf info[l] = i > 0, the l-th batch instance is singular.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrf_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeblttrf_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeblttrf_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeblttrf_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBLTTRF_NPVT_STRIDED_BATCHED computes the LU factorization of a batch of block tridiagonal\nmatrices without partial pivoting.\n\n\\details The LU factorization of a block tridiagonal matrix \\f$M_l\\f$ in the batch\n\n\\f[\nM_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\n\\f]\n\nwith \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, can be represented as\n\n\\f[\nM_l = \\left[\\begin{array}{cccc}\nL_{l1} \\\\\nA_{l1} & L_{l2}\\\\\n& \\ddots & \\ddots \\\\\n&  & A_{l(n-1)} & L_{ln}\n\\end{array}\\right] \\left[\\begin{array}{cccc}\nI & U_{l1} \\\\\n& \\ddots & \\ddots \\\\\n&  & I & U_{l(n-1)}\\\\\n&  &  & I\n\\end{array}\\right] = L_lU_l\n\\f]\n\nwhere the blocks \\f$L_{li}\\f$ and \\f$U_{li}\\f$ are also general blocks of size nb.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nContains the blocks A_{li} arranged one after the other.\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_{li}.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one block A_{li} to the same block in the next batch\ninstance A_{(l+1)i}.\nThere is no restriction for the value of strideA. Normal use case is strideA >=\nlda*nb*nblocks.\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, contains the blocks B_{li} arranged one after the other.\nOn exit it is overwritten by blocks L_{li} in factorized form as returned by\n\\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\"\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of matrix blocks B_{li}.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideB. Normal use case is strideB >=\nldb*nb*nblocks.\n@param[inout]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nOn entry, contains the blocks C_{li} arranged one after the other.\nOn exit it is overwritten by blocks U_{li}.\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of matrix blocks C_{li}.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideC. Normal use case is strideC >=\nldc*nb*nblocks.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of l-th batch instance.\nIf info[l] = i > 0, the l-th batch instance is singular.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrf_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeblttrf_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeblttrf_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeblttrf_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBLTTRF_NPVT_INTERLEAVED_BATCHED computes the LU factorization of a batch of block tridiagonal\nmatrices without partial pivoting.\n\n\\details The LU factorization of a block tridiagonal matrix \\f$M_l\\f$ in the batch\n\n\\f[\nM_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\n\\f]\n\nwith \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, can be represented as\n\n\\f[\nM_l = \\left[\\begin{array}{cccc}\nL_{l1} \\\\\nA_{l1} & L_{l2}\\\\\n& \\ddots & \\ddots \\\\\n&  & A_{l(n-1)} & L_{ln}\n\\end{array}\\right] \\left[\\begin{array}{cccc}\nI & U_{l1} \\\\\n& \\ddots & \\ddots \\\\\n&  & I & U_{l(n-1)}\\\\\n&  &  & I\n\\end{array}\\right] = L_lU_l\n\\f]\n\nwhere the blocks \\f$L_{li}\\f$ and \\f$U_{li}\\f$ are also general blocks of size nb.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nContains the blocks A_{li} arranged one after the other.\n@param[in]\ninca        rocblas_int. inca > 0.\nStride from the start of one row of A_{li} to the next. Normal use cases are\ninca = 1 (strided batched case) or inca = batch_count (interleaved batched case).\n@param[in]\nlda         rocblas_int. lda >= inca * nb.\nSpecifies the leading dimension of blocks A_{li}, i.e. the stride from the start\nof one column of A_{li} to the next.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one block A_{li} to the same block in the next batch\ninstance A_{(l+1)i}.\nThere is no restriction for the value of strideA. Normal use cases are strideA >=\nlda*nb*nblocks (strided batched case) or strideA = 1 (interleaved batched case).\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, contains the blocks B_{li} arranged one after the other.\nOn exit it is overwritten by blocks L_{li} in factorized form as returned by\n\\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\"\n@param[in]\nincb        rocblas_int. incb > 0.\nStride from the start of one row of B_{li} to the next. Normal use cases are\nincb = 1 (strided batched case) or incb = batch_count (interleaved batched case).\n@param[in]\nldb         rocblas_int. ldb >= incb * nb.\nSpecifies the leading dimension of blocks B_{li}, i.e. the stride from the start\nof one column of B_{li} to the next.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideB. Normal use cases are strideB >=\nldb*nb*nblocks (strided batched case) or strideB = 1 (interleaved batched case).\n@param[inout]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nOn entry, contains the blocks C_{li} arranged one after the other.\nOn exit it is overwritten by blocks U_{li}.\n@param[in]\nincc        rocblas_int. incc > 0.\nStride from the start of one row of C_{li} to the next. Normal use cases are\nincc = 1 (strided batched case) or incc = batch_count (interleaved batched case).\n@param[in]\nldc         rocblas_int. ldc >= incc * nb.\nSpecifies the leading dimension of blocks C_{li}, i.e. the stride from the start\nof one column of C_{li} to the next.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideC. Normal use cases are strideC >=\nldc*nb*nblocks (strided batched case) or strideC = 1 (interleaved batched case).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of l-th batch instance.\nIf info[l] = i > 0, the l-th batch instance is singular.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrf_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f32,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f32,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeblttrf_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f64,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f64,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeblttrf_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_float_complex,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_float_complex,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeblttrf_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_double_complex,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_double_complex,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBLTTRS_NPVT solves a system of linear equations given by a block tridiagonal matrix\nin its factorized form (without partial pivoting).\n\n\\details The linear system has the form\n\n\\f[\nMX = \\left[\\begin{array}{ccccc}\nB_1 & C_1\\\\\nA_1 & B_2 & C_2\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{n-2} & B_{n-1} & C_{n-1}\\\\\n&  &  & A_{n-1} & B_n\n\\end{array}\\right]\\left[\\begin{array}{c}\nX_1\\\\\nX_2\\\\\nX_3\\\\\n\\vdots\\\\\nX_n\n\\end{array}\\right]=\\left[\\begin{array}{c}\nR_1\\\\\nR_2\\\\\nR_3\\\\\n\\vdots\\\\\nR_n\n\\end{array}\\right]=R\n\\f]\n\nwhere matrix M has \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, and the right-hand-side\nblocks \\f$R_i\\f$ are general blocks of size nb-by-nrhs. The blocks of matrix M should be in\nthe factorized form as returned by \\ref rocsolver_sgeblttrf_npvt \"GEBLTTRF_NPVT\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of the matrix.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns of blocks R_i.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*nb*(nblocks-1).\nContains the blocks A_i as returned by \\ref rocsolver_sgeblttrf_npvt \"GEBLTTRF_NPVT\".\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_i.\n@param[in]\nB           pointer to type. Array on the GPU of dimension ldb*nb*nblocks.\nContains the blocks B_i as returned by \\ref rocsolver_sgeblttrf_npvt \"GEBLTTRF_NPVT\".\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_i.\n@param[in]\nC           pointer to type. Array on the GPU of dimension ldc*nb*(nblocks-1).\nContains the blocks C_i as returned by \\ref rocsolver_sgeblttrf_npvt \"GEBLTTRF_NPVT\".\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_i.\n@param[inout]\nX           pointer to type. Array on the GPU of dimension ldx*nblocks*nrhs.\nOn entry, X contains the right-hand-side blocks R_i. It is overwritten by solution\nvectors X_i on exit.\n@param[in]\nldx         rocblas_int. ldx >= nb.\nSpecifies the leading dimension of blocks X_i."]
    pub fn rocsolver_sgeblttrs_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        X: *mut f32,
        ldx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeblttrs_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        X: *mut f64,
        ldx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeblttrs_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        X: *mut rocblas_float_complex,
        ldx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeblttrs_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        X: *mut rocblas_double_complex,
        ldx: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBLTTRS_NPVT_BATCHED solves a batch of system of linear equations given by block tridiagonal\nmatrices in its factorized form (without partial pivoting).\n\n\\details Each linear system has the form\n\n\\f[\nM_lX_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\\left[\\begin{array}{c}\nX_{l1}\\\\\nX_{l2}\\\\\nX_{l3}\\\\\n\\vdots\\\\\nX_{ln}\n\\end{array}\\right]=\\left[\\begin{array}{c}\nR_{l1}\\\\\nR_{l2}\\\\\nR_{l3}\\\\\n\\vdots\\\\\nR_{ln}\n\\end{array}\\right]=R_l\n\\f]\n\nwhere matrix \\f$M_l\\f$ has \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, and the right-hand-side\nblocks \\f$R_{li}\\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \\f$M_l\\f$ should be in\nthe factorized form as returned by \\ref rocsolver_sgeblttrf_npvt_batched \"GEBLTTRF_NPVT_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns of blocks R_{li}.\n@param[in]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension\nlda*nb*(nblocks-1).\nContains the blocks A_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_batched \"GEBLTTRF_NPVT_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_{li}.\n@param[in]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension\nlda*nb*nblocks.\nContains the blocks B_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_batched \"GEBLTTRF_NPVT_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_{li}.\n@param[in]\nC           array of pointers to type. Each pointer points to an array on the GPU of dimension\nldc*nb*(nblocks-1).\nContains the blocks C_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_batched \"GEBLTTRF_NPVT_BATCHED\".\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_{li}.\n@param[inout]\nX           array of pointers to type. Each pointer points to an array on the GPU of dimension\nldx*nblocks*nrhs.\nOn entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution\nvectors X_{li} on exit.\n@param[in]\nldx         rocblas_int. ldx >= nb.\nSpecifies the leading dimension of blocks X_{li}.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrs_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        X: *const *mut f32,
        ldx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeblttrs_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        X: *const *mut f64,
        ldx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeblttrs_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        X: *const *mut rocblas_float_complex,
        ldx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeblttrs_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        X: *const *mut rocblas_double_complex,
        ldx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBLTTRS_NPVT_STRIDED_BATCHED solves a batch of system of linear equations given by block\ntridiagonal matrices in its factorized form (without partial pivoting).\n\n\\details Each linear system has the form\n\n\\f[\nM_lX_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\\left[\\begin{array}{c}\nX_{l1}\\\\\nX_{l2}\\\\\nX_{l3}\\\\\n\\vdots\\\\\nX_{ln}\n\\end{array}\\right]=\\left[\\begin{array}{c}\nR_{l1}\\\\\nR_{l2}\\\\\nR_{l3}\\\\\n\\vdots\\\\\nR_{ln}\n\\end{array}\\right]=R_l\n\\f]\n\nwhere matrix \\f$M_l\\f$ has \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, and the right-hand-side\nblocks \\f$R_{li}\\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \\f$M_l\\f$ should be in\nthe factorized form as returned by \\ref rocsolver_sgeblttrf_npvt_strided_batched \"GEBLTTRF_NPVT_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns of blocks R_{li}.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nContains the blocks A_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_strided_batched \"GEBLTTRF_NPVT_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_{li}.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one block A_{li} to the same block in the next batch\ninstance A_{(l+1)i}.\nThere is no restriction for the value of strideA. Normal use case is strideA >=\nlda*nb*nblocks\n@param[in]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nContains the blocks B_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_strided_batched \"GEBLTTRF_NPVT_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_{li}.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideB. Normal use case is strideB >=\nldb*nb*nblocks\n@param[in]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nContains the blocks C_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_strided_batched \"GEBLTTRF_NPVT_STRIDED_BATCHED\".\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_{li}.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one block C_{li} to the same block in the next batch\ninstance C_{(l+1)i}.\nThere is no restriction for the value of strideC. Normal use case is strideC >=\nldc*nb*nblocks\n@param[inout]\nX           pointer to type. Array on the GPU (the size depends on the value of strideX).\nOn entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution\nvectors X_{li} on exit.\n@param[in]\nldx         rocblas_int. ldx >= nb.\nSpecifies the leading dimension of blocks X_{li}.\n@param[in]\nstrideX     rocblas_stride.\nStride from the start of one block X_{li} to the same block in the next batch\ninstance X_{(l+1)i}.\nThere is no restriction for the value of strideX. Normal use case is strideX >=\nldx*nblocks*nrhs\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrs_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut f32,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeblttrs_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut f64,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeblttrs_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut rocblas_float_complex,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeblttrs_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut rocblas_double_complex,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief GEBLTTRS_NPVT_INTERLEAVED_BATCHED solves a batch of system of linear equations given by block\ntridiagonal matrices in its factorized form (without partial pivoting).\n\n\\details Each linear system has the form\n\n\\f[\nM_lX_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{ll}\\\\\nA_{l1} & B_{ll} & C_{ll}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\\left[\\begin{array}{c}\nX_{l1}\\\\\nX_{l2}\\\\\nX_{l3}\\\\\n\\vdots\\\\\nX_{ln}\n\\end{array}\\right]=\\left[\\begin{array}{c}\nR_{l1}\\\\\nR_{l2}\\\\\nR_{l3}\\\\\n\\vdots\\\\\nR_{ln}\n\\end{array}\\right]=R_l\n\\f]\n\nwhere matrix \\f$M_l\\f$ has \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, and the right-hand-side\nblocks \\f$R_{li}\\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \\f$M_l\\f$ should be in\nthe factorized form as returned by \\ref rocsolver_sgeblttrf_npvt_interleaved_batched \"GEBLTTRF_NPVT_INTERLEAVED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns of blocks R_{li}.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nContains the blocks A_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_interleaved_batched \"GEBLTTRF_NPVT_INTERLEAVED_BATCHED\".\n@param[in]\ninca        rocblas_int. inca > 0.\nStride from the start of one row of A_{li} to the next. Normal use cases are\ninca = 1 (strided batched case) or inca = batch_count (interleaved batched case).\n@param[in]\nlda         rocblas_int. lda >= inca * nb.\nSpecifies the leading dimension of blocks A_{li}, i.e. the stride from the start\nof one column of A_{li} to the next.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one block A_{li} to the same block in the next batch\ninstance A_{(l+1)i}.\nThere is no restriction for the value of strideA. Normal use cases are strideA >=\nlda*nb*nblocks (strided batched case) or strideA = 1 (interleaved batched case).\n@param[in]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nContains the blocks B_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_interleaved_batched \"GEBLTTRF_NPVT_INTERLEAVED_BATCHED\".\n@param[in]\nincb        rocblas_int. incb > 0.\nStride from the start of one row of B_{li} to the next. Normal use cases are\nincb = 1 (strided batched case) or incb = batch_count (interleaved batched case).\n@param[in]\nldb         rocblas_int. ldb >= incb * nb.\nSpecifies the leading dimension of blocks B_{li}, i.e. the stride from the start\nof one column of B_{li} to the next.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideB. Normal use cases are strideB >=\nldb*nb*nblocks (strided batched case) or strideB = 1 (interleaved batched case).\n@param[in]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nContains the blocks C_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_interleaved_batched \"GEBLTTRF_NPVT_INTERLEAVED_BATCHED\".\n@param[in]\nincc        rocblas_int. incc > 0.\nStride from the start of one row of C_{li} to the next. Normal use cases are\nincc = 1 (strided batched case) or incc = batch_count (interleaved batched case).\n@param[in]\nldc         rocblas_int. ldc >= incc * nb.\nSpecifies the leading dimension of blocks C_{li}, i.e. the stride from the start\nof one column of C_{li} to the next.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one block C_{li} to the same block in the next batch\ninstance C_{(l+1)i}.\nThere is no restriction for the value of strideC. Normal use cases are strideC >=\nldc*nb*nblocks (strided batched case) or strideC = 1 (interleaved batched case).\n@param[inout]\nX           pointer to type. Array on the GPU (the size depends on the value of strideX).\nOn entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution\nvectors X_{li} on exit.\n@param[in]\nincx        rocblas_int. incx > 0.\nStride from the start of one row of X_{li} to the next. Normal use cases are\nincx = 1 (strided batched case) or incx = batch_count (interleaved batched case).\n@param[in]\nldx         rocblas_int. ldx >= incx * nb.\nSpecifies the leading dimension of blocks X_{li}, i.e. the stride from the start\nof one column of X_{li} to the next.\n@param[in]\nstrideX     rocblas_stride.\nStride from the start of one block X_{li} to the same block in the next batch\ninstance X_{(l+1)i}.\nThere is no restriction for the value of strideX. Normal use cases are strideX >=\nldx*nrhs*nblocks (strided batched case) or strideX = 1 (interleaved batched case).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrs_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f32,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut f32,
        incx: rocblas_int,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dgeblttrs_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f64,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut f64,
        incx: rocblas_int,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_cgeblttrs_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_float_complex,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut rocblas_float_complex,
        incx: rocblas_int,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_zgeblttrs_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_double_complex,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut rocblas_double_complex,
        incx: rocblas_int,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief CREATE_RFINFO initializes the structure rfinfo that contains the meta data and descriptors of the involved matrices\nrequired by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details\n@param[out]\nrfinfo      #rocsolver_rfinfo.\nThe pointer to the rfinfo struct to be initialized.\n@param[in]\nhandle      rocblas_handle."]
    pub fn rocsolver_create_rfinfo(
        rfinfo: *mut rocsolver_rfinfo,
        handle: rocblas_handle,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief DESTROY_RFINFO destroys the structure rfinfo used by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details\n@param[in]\nrfinfo      #rocsolver_rfinfo.\nThe rfinfo struct to be destroyed."]
    pub fn rocsolver_destroy_rfinfo(rfinfo: rocsolver_rfinfo) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief SET_RFINFO_MODE sets the mode of the structure rfinfo required by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details\n@param[in]\nrfinfo      #rocsolver_rfinfo.\nThe rfinfo struct to be set up.\n@param[in]\nmode        #rocsolver_rfinfo_mode.\nUse rocsolver_rfinfo_mode_cholesky when the Cholesky factorization is required."]
    pub fn rocsolver_set_rfinfo_mode(
        rfinfo: rocsolver_rfinfo,
        mode: rocsolver_rfinfo_mode,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief GET_RFINFO_MODE gets the mode of the structure rfinfo required by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details\n@param[in]\nrfinfo      #rocsolver_rfinfo.\nThe referenced rfinfo struct.\n@param[out]\nmode        #rocsolver_rfinfo_mode.\nThe queried mode."]
    pub fn rocsolver_get_rfinfo_mode(
        rfinfo: rocsolver_rfinfo,
        mode: *mut rocsolver_rfinfo_mode,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief CSRRF_SUMLU bundles the factors \\f$L\\f$ and \\f$U\\f$, associated with the LU factorization\nof a sparse matrix \\f$A\\f$, into a single sparse matrix \\f$T=(L-I)+U\\f$.\n\n\\details Factor \\f$L\\f$ is a sparse lower triangular matrix with unit diagonal elements, and\n\\f$U\\f$ is a sparse upper triangular matrix. The resulting sparse matrix \\f$T\\f$ combines both\nsparse factors without storing the unit diagonal; in other words, the number of non-zero\nelements of T, nnzT, is given by nnzT = nnzL - n + nnzU.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnnzL        rocblas_int. nnzL >= n.\nThe number of non-zero elements in L.\n@param[in]\nptrL        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indL and valL.\nThe last element of ptrL is equal to nnzL.\n@param[in]\nindL        pointer to rocblas_int. Array on the GPU of dimension nnzL.\nIt contains the column indices of the non-zero elements of L. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalL        pointer to type. Array on the GPU of dimension nnzL.\nThe values of the non-zero elements of L.\n@param[in]\nnnzU        rocblas_int. nnzU >= 0.\nThe number of non-zero elements in U.\n@param[in]\nptrU        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indU and valU.\nThe last element of ptrU is equal to nnzU.\n@param[in]\nindU        pointer to rocblas_int. Array on the GPU of dimension nnzU.\nIt contains the column indices of the non-zero elements of U. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalU        pointer to type. Array on the GPU of dimension nnzU.\nThe values of the non-zero elements of U.\n@param[out]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[out]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[out]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of T."]
    pub fn rocsolver_scsrrf_sumlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzL: rocblas_int,
        ptrL: *mut rocblas_int,
        indL: *mut rocblas_int,
        valL: *mut f32,
        nnzU: rocblas_int,
        ptrU: *mut rocblas_int,
        indU: *mut rocblas_int,
        valU: *mut f32,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dcsrrf_sumlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzL: rocblas_int,
        ptrL: *mut rocblas_int,
        indL: *mut rocblas_int,
        valL: *mut f64,
        nnzU: rocblas_int,
        ptrU: *mut rocblas_int,
        indU: *mut rocblas_int,
        valU: *mut f64,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief CSRRF_SPLITLU splits the factors \\f$L\\f$ and \\f$U\\f$, associated with the LU factorization\nof a sparse matrix \\f$A\\f$, from a bundled matrix \\f$T=(L-I)+U\\f$.\n\n\\details Factor \\f$L\\f$ is a sparse lower triangular matrix with unit diagonal elements, and\n\\f$U\\f$ is a sparse upper triangular matrix. Conceptually, on input, U is stored on the diagonal\nand upper part of \\f$T\\f$, while the non diagonal elements of \\f$L\\f$ are stored on the strictly\nlower part of \\f$T\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of T.\n@param[out]\nptrL        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indL and valL.\nThe last element of ptrL is equal to nnzL.\n@param[out]\nindL        pointer to rocblas_int. Array on the GPU of dimension nnzL.\nIt contains the column indices of the non-zero elements of L. Indices are\nsorted by row and by column within each row. (If nnzL is not known in advance,\nthe size of this array could be set to nnzT + n as an upper bound).\n@param[out]\nvalL        pointer to type. Array on the GPU of dimension nnzL.\nThe values of the non-zero elements of L. (If nnzL is not known in advance,\nthe size of this array could be set to nnzT + n as an upper bound).\n@param[out]\nptrU        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indU and valU.\nThe last element of ptrU is equal to nnzU.\n@param[out]\nindU        pointer to rocblas_int. Array on the GPU of dimension nnzU.\nIt contains the column indices of the non-zero elements of U. Indices are\nsorted by row and by column within each row. (If nnzU is not known in advance,\nthe size of this array could be set to nnzT as an upper bound).\n@param[out]\nvalU        pointer to type. Array on the GPU of dimension nnzU.\nThe values of the non-zero elements of U. (If nnzU is not known in advance,\nthe size of this array could be set to nnzT as an upper bound)."]
    pub fn rocsolver_scsrrf_splitlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        ptrL: *mut rocblas_int,
        indL: *mut rocblas_int,
        valL: *mut f32,
        ptrU: *mut rocblas_int,
        indU: *mut rocblas_int,
        valU: *mut f32,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dcsrrf_splitlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        ptrL: *mut rocblas_int,
        indL: *mut rocblas_int,
        valL: *mut f64,
        ptrU: *mut rocblas_int,
        indU: *mut rocblas_int,
        valU: *mut f64,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief CSRRF_ANALYSIS performs the analysis phase required by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details Consider a sparse matrix \\f$M\\f$ previously factorized as\n\n\\f[\nQ^TMQ = L_ML_M^T\n\\f]\n\n(Cholesky factorization for the symmetric positive definite case), or\n\n\\f[\nPMQ = L_MU_M\n\\f]\n\n(LU factorization for the general case)\n\nwhere \\f$L_M\\f$ is lower triangular (with unit diagonal in the general case), \\f$U_M\\f$ is upper triangular, and \\f$P\\f$\nand \\f$Q\\f$ are permutation matrices associated with pivoting and re-ordering (to minimize\nfill-in), respectively. The meta data generated by this routine is collected in the output parameter\nrfinfo. This information will allow the fast re-factorization of another sparse matrix \\f$A\\f$ as\n\n\\f[\nQ^TAQ = L_AL_A^T, \\quad \\text{or}\n\\f]\n\n\\f[\nPAQ = L_AU_A,\n\\f]\n\nand, eventually, the computation of the solution vector \\f$X\\f$ of any linear system of the form\n\n\\f[\nAX = B\n\\f]\n\nas long as \\f$A\\f$ has the same sparsity pattern as the previous matrix \\f$M\\f$.\n\nThis function supposes that the rfinfo struct has been initialized by \\ref rocsolver_create_rfinfo \"RFINFO_CREATE\".\nBy default, rfinfo is set up to work with the LU factorization (general matrices). If the matrix is symmetric positive definite,\nand the Cholesky factorization is\ndesired, then the corresponding mode must be manually set up by \\ref rocsolver_set_rfinfo_mode \"SET_RFINFO_MODE\". This function\ndoes not automatically detect symmetry.\n\nFor the LU factorization mode, the LU factors \\f$L_M\\f$ and \\f$U_M\\f$ must be passed in a bundle\nmatrix \\f$T=(L_M-I)+U_M\\f$ as returned by \\ref rocsolver_scsrrf_sumlu \"CSRRF_SUMLU\". For the Cholesky mode,\nthe lower triangular part of \\f$T\\f$ must contain the Cholesky factor \\f$L_M\\f$; the strictly upper triangular\npart of \\f$T\\f$ will be ignored. Similarly, the strictly upper triangular part of \\f$M\\f$ is ignored when working\nin Cholesky mode.\n\n\\note\nIf only a re-factorization will be executed (i.e. no solver phase), then nrhs can be set to zero\nand B can be null.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix M.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right-hand-sides (columns of matrix B). Set nrhs to zero when only the\nre-factorization is needed.\n@param[in]\nnnzM        rocblas_int. nnzM >= 0.\nThe number of non-zero elements in M.\n@param[in]\nptrM        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indM and valM.\nThe last element of ptrM is equal to nnzM.\n@param[in]\nindM        pointer to rocblas_int. Array on the GPU of dimension nnzM.\nIt contains the column indices of the non-zero elements of M. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalM        pointer to type. Array on the GPU of dimension nnzM.\nThe values of the non-zero elements of M. The strictly upper triangular entries are\nnot referenced when working in Cholesky mode.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of T. The strictly upper triangular entries are\nnot referenced when working in Cholesky mode.\n@param[in]\npivP        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix P, i.e. the\norder in which the rows of matrix M were re-arranged. When working in Cholesky mode,\nthis array is not referenced and can be null.\n@param[in]\npivQ        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix Q, i.e. the\norder in which the columns of matrix M were re-arranged.\n@param[in]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nThe right hand side matrix B. It can be null if only the re-factorization is needed.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B.\n@param[out]\nrfinfo      rocsolver_rfinfo.\nStructure that holds the meta data generated in the analysis phase."]
    pub fn rocsolver_scsrrf_analysis(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        nnzM: rocblas_int,
        ptrM: *mut rocblas_int,
        indM: *mut rocblas_int,
        valM: *mut f32,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dcsrrf_analysis(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        nnzM: rocblas_int,
        ptrM: *mut rocblas_int,
        indM: *mut rocblas_int,
        valM: *mut f64,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief CSRRF_REFACTLU performs a fast LU factorization of a sparse matrix \\f$A\\f$ based on the\ninformation from the factorization of a previous matrix \\f$M\\f$ with the same sparsity pattern\n(re-factorization).\n\n\\details Consider a sparse matrix \\f$M\\f$ previously factorized as\n\n\\f[\nPMQ = L_MU_M\n\\f]\n\nwhere \\f$L_M\\f$ is lower triangular with unit diagonal, \\f$U_M\\f$ is upper triangular, and \\f$P\\f$\nand \\f$Q\\f$ are permutation matrices associated with pivoting and re-ordering (to minimize\nfill-in), respectively. If \\f$A\\f$ has the same sparsity pattern as \\f$M\\f$, then the re-factorization\n\n\\f[\nPAQ = L_AU_A\n\\f]\n\ncan be computed numerically without a symbolic analysis phase.\n\nThis function supposes that rfinfo has been updated, by function \\ref rocsolver_scsrrf_analysis \"CSRRF_ANALYSIS\",\nafter the analysis phase of the previous matrix M and its initial factorization. Both functions, CSRRF_ANALYSIS and\nCSRRF_REFACTLU must be run with the same rfinfo mode (LU factorization, the default mode), otherwise the workflow will\nresult in an error.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnnzA        rocblas_int. nnzA >= 0.\nThe number of non-zero elements in A.\n@param[in]\nptrA        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indA and valA.\nThe last element of ptrM is equal to nnzA.\n@param[in]\nindA        pointer to rocblas_int. Array on the GPU of dimension nnzA.\nIt contains the column indices of the non-zero elements of M. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalA        pointer to type. Array on the GPU of dimension nnzA.\nThe values of the non-zero elements of A.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[out]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of the new bundle matrix (L_A - I) + U_A.\n@param[in]\npivP        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix P, i.e. the\norder in which the rows of matrix M were re-arranged.\n@param[in]\npivQ        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix Q, i.e. the\norder in which the columns of matrix M were re-arranged.\n@param[in]\nrfinfo      rocsolver_rfinfo.\nStructure that holds the meta data generated in the analysis phase."]
    pub fn rocsolver_scsrrf_refactlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzA: rocblas_int,
        ptrA: *mut rocblas_int,
        indA: *mut rocblas_int,
        valA: *mut f32,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dcsrrf_refactlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzA: rocblas_int,
        ptrA: *mut rocblas_int,
        indA: *mut rocblas_int,
        valA: *mut f64,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief CSRRF_REFACTCHOL performs a fast Cholesky factorization of a sparse symmetric positive definite matrix \\f$A\\f$\nbased on the information from the factorization of a previous matrix \\f$M\\f$ with the same sparsity pattern\n(re-factorization).\n\n\\details Consider a sparse matrix \\f$M\\f$ previously factorized as\n\n\\f[\nQ^TMQ = L_ML_M^T\n\\f]\n\nwhere \\f$L_M\\f$ is lower triangular, and \\f$Q\\f$ is a permutation matrices associated with re-ordering to minimize\nfill-in. If \\f$A\\f$ has the same sparsity pattern as \\f$M\\f$, then the re-factorization\n\n\\f[\nQ^TAQ = L_AL_A^T\n\\f]\n\ncan be computed numerically without a symbolic analysis phase.\n\nThis function supposes that rfinfo has been updated by function \\ref rocsolver_scsrrf_analysis \"CSRRF_ANALYSIS\",\nafter the analysis phase of the previous matrix M and its initial factorization. Both functions, CSRRF_ANALYSIS and\nCSRRF_REFACTCHOL must be run with the same rfinfo mode (Cholesky factorization), otherwise the workflow will\nresult in an error.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnnzA        rocblas_int. nnzA >= 0.\nThe number of non-zero elements in A.\n@param[in]\nptrA        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indA and valA.\nThe last element of ptrM is equal to nnzA.\n@param[in]\nindA        pointer to rocblas_int. Array on the GPU of dimension nnzA.\nIt contains the column indices of the non-zero elements of M. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalA        pointer to type. Array on the GPU of dimension nnzA.\nThe values of the non-zero elements of A. The strictly upper triangular entries are\nnot referenced.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[out]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of the new Cholesky factor L_A.\nThe strictly upper triangular entries of this array are not referenced.\n@param[in]\npivQ        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix Q, i.e. the\norder in which the columns of matrix M were re-arranged.\n@param[in]\nrfinfo      #rocsolver_rfinfo.\nStructure that holds the meta data generated in the analysis phase."]
    pub fn rocsolver_scsrrf_refactchol(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzA: rocblas_int,
        ptrA: *mut rocblas_int,
        indA: *mut rocblas_int,
        valA: *mut f32,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        pivQ: *mut rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dcsrrf_refactchol(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzA: rocblas_int,
        ptrA: *mut rocblas_int,
        indA: *mut rocblas_int,
        valA: *mut f64,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        pivQ: *mut rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    #[doc = " @{\n\\brief CSRRF_SOLVE solves a linear system with sparse coefficient matrix \\f$A\\f$ in its\nfactorized form.\n\n\\details The linear system is of the form\n\n\\f[\nAX = B\n\\f]\n\nwhere the sparse matrix \\f$A\\f$ is factorized as\n\n\\f[\nQ^TAQ = L_AL_A^T\n\\f]\n\n(Cholesky factorization for the symmetric positive definite case), or\n\n\\f[\nPAQ = L_AU_A\n\\f]\n\n(LU factorization for the general case),\n\nand \\f$B\\f$ is a dense matrix of right hand sides.\n\nThis function supposes that rfinfo has been updated by function \\ref rocsolver_scsrrf_analysis \"CSRRF_ANALYSIS\",\nafter the analysis phase. Both functions, CSRRF_ANALYSIS and\nCSRRF_SOLVE must be run with the same rfinfo mode (LU or Cholesky factorization), otherwise the workflow will\nresult in an error.\n\nFor the LU factorization mode, the LU factors \\f$L_A\\f$ and \\f$U_A\\f$ must be passed in a bundle matrix \\f$T=(L_A-I)+U_A\\f$\nas returned by \\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" or \\ref rocsolver_scsrrf_sumlu \"CSRRF_SUMLU\". For the Cholesky mode,\nthe lower triangular part of \\f$T\\f$ must contain the Cholesky factor \\f$L_A\\f$; the strictly upper triangular\npart of \\f$T\\f$ will be ignored.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e. the number of columns of matrix B.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of T. The strictly upper triangular entries are\nnot referenced when working in Cholesky mode.\n@param[in]\npivP        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix P, i.e. the\norder in which the rows of matrix A were re-arranged. When working in Cholesky mode,\nthis array is not referenced and can be null.\n@param[in]\npivQ        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix Q, i.e. the\norder in which the columns of matrix A were re-arranged.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry the right hand side matrix B. On exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B.\n@param[in]\nrfinfo      rocsolver_rfinfo.\nStructure that holds the meta data generated in the analysis phase."]
    pub fn rocsolver_scsrrf_solve(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
extern "C" {
    #[must_use]
    pub fn rocsolver_dcsrrf_solve(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
